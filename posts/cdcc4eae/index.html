<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>分布式事务 | 樱桃先生</title><meta name="author" content="樱桃先生"><meta name="copyright" content="樱桃先生"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="一、分布式事务前奏 事务：事务是由一组操作构成的可靠的独立的工作单元，事务具备ACID的特性，即原子性、一致性、隔离性和持久性。 本地事务：当事务由资源管理器本地管理时被称作本地事务。本地事务的优点就是支持严格的ACID特性，高效，可靠，状态可以只在资源管理器中维护，而且应用编程模型简单。但是本地事务不具备分布式事务的处理能力，隔离的最小单位受限于资源管理器。 全局事务：当事务由全局事务管理器进行">
<meta property="og:type" content="article">
<meta property="og:title" content="分布式事务">
<meta property="og:url" content="http://example.com/posts/cdcc4eae/index.html">
<meta property="og:site_name" content="樱桃先生">
<meta property="og:description" content="一、分布式事务前奏 事务：事务是由一组操作构成的可靠的独立的工作单元，事务具备ACID的特性，即原子性、一致性、隔离性和持久性。 本地事务：当事务由资源管理器本地管理时被称作本地事务。本地事务的优点就是支持严格的ACID特性，高效，可靠，状态可以只在资源管理器中维护，而且应用编程模型简单。但是本地事务不具备分布式事务的处理能力，隔离的最小单位受限于资源管理器。 全局事务：当事务由全局事务管理器进行">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://gitee.com/xyingtao/blogimage/raw/master/img/%E5%88%86%E5%B8%83%E5%BC%8F.jpg">
<meta property="article:published_time" content="2020-09-08T04:00:00.000Z">
<meta property="article:modified_time" content="2022-08-27T09:40:36.720Z">
<meta property="article:author" content="樱桃先生">
<meta property="article:tag" content="事务">
<meta property="article:tag" content="分布式">
<meta property="article:tag" content="seata">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gitee.com/xyingtao/blogimage/raw/master/img/%E5%88%86%E5%B8%83%E5%BC%8F.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "分布式事务",
  "url": "http://example.com/posts/cdcc4eae/",
  "image": "https://gitee.com/xyingtao/blogimage/raw/master/img/分布式.jpg",
  "datePublished": "2020-09-08T04:00:00.000Z",
  "dateModified": "2022-08-27T09:40:36.720Z",
  "author": [
    {
      "@type": "Person",
      "name": "樱桃先生",
      "url": "http://example.com"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/posts/cdcc4eae/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '分布式事务',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2022/08/20/hk9Zvq4YRsIcnrw.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">78</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">65</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">21</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/gallery/"><i class="fa-fw fas fa-camera"></i><span> 图库</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fas fa-comment-dots"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://gitee.com/xyingtao/blogimage/raw/master/img/分布式.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">樱桃先生</span></a><a class="nav-page-title" href="/"><span class="site-name">分布式事务</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/gallery/"><i class="fa-fw fas fa-camera"></i><span> 图库</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fas fa-comment-dots"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">分布式事务</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-09-08T04:00:00.000Z" title="发表于 2020-09-08 12:00:00">2020-09-08</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-08-27T09:40:36.720Z" title="更新于 2022-08-27 17:40:36">2022-08-27</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%8A%80%E6%9C%AF/%E5%88%86%E5%B8%83%E5%BC%8F/">分布式</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="一、分布式事务前奏"><a href="#一、分布式事务前奏" class="headerlink" title="一、分布式事务前奏"></a>一、分布式事务前奏</h1><ul>
<li>事务：事务是由一组操作构成的可靠的独立的工作单元，事务具备ACID的特性，即<code>原子性</code>、<code>一致性</code>、<code>隔离性</code>和<code>持久性</code>。</li>
<li>本地事务：当事务由资源管理器本地管理时被称作本地事务。本地事务的优点就是支持严格的ACID特性，高效，可靠，状态可以只在资源管理器中维护，而且应用编程模型简单。但是本地事务不具备分布式事务的处理能力，隔离的最小单位受限于资源管理器。</li>
<li>全局事务：当事务由全局事务管理器进行全局管理时成为全局事务，事务管理器负责管理全局的事务状态和参与的资源，协同资源的一致提交回滚。</li>
<li>TX协议：应用或者应用服务器与事务管理器的接口。</li>
<li>XA协议：全局事务管理器与资源管理器的接口。XA是由X&#x2F;Open组织提出的分布式事务规范。该规范主要定义了全局事务管理器和局部资源管理器之间的接口。主流的数据库产品都实现了XA接口。XA接口是一个双向的系统接口，在事务管理器以及多个资源管理器之间作为通信桥梁。之所以需要XA是因为在分布式系统中从理论上讲两台机器是无法达到一致性状态的，因此引入一个单点进行协调。由全局事务管理器管理和协调的事务可以跨越多个资源和进程。全局事务管理器一般使用XA二阶段协议与数据库进行交互。</li>
<li>AP：应用程序，可以理解为使用<code>DTP（Data Tools Platform）</code>的程序。</li>
<li>RM：资源管理器，这里可以是一个<code>DBMS</code>或者<code>消息服务器管理系统</code>，应用程序通过资源管理器对资源进行控制，资源必须实现XA定义的接口。资源管理器负责控制和管理实际的资源。</li>
<li>TM：<code>事务管理器</code>，负责协调和管理事务，提供给AP编程接口以及管理资源管理器。事务管理器控制着全局事务，管理事务的生命周期，并且协调资源。</li>
<li>两阶段提交协议：XA用于在全局事务中协调多个资源的机制。TM和RM之间采取两阶段提交的方案来解决一致性问题。两节点提交需要一个协调者（TM）来掌控所有参与者（RM）节点的操作结果并且指引这些节点是否需要最终提交。两阶段提交的局限在于协议成本，准备阶段的持久成本，全局事务状态的持久成本，潜在故障点多带来的脆弱性，准备后，提交前的故障引发一系列隔离与恢复难题。</li>
<li>BASE理论：BA指的是基本业务可用性，支持分区失败，S表示柔性状态，也就是允许短时间内不同步，E表示最终一致性，数据最终是一致的，但是实时是不一致的。原子性和持久性必须从根本上保障，为了可用性、性能和服务降级的需要，只有降低一致性和隔离性的要求。</li>
<li>CAP定理：对于共享数据系统，最多只能同时拥有CAP其中的两个，任意两个都有其适应的场景，真是的业务系统中通常是ACID与CAP的混合体。分布式系统中最重要的是满足业务需求，而不是追求高度抽象，绝对的系统特性。C表示一致性，也就是所有用户看到的数据是一样的。A表示可用性，是指总能找到一个可用的数据副本。P表示分区容错性，能够容忍网络中断等故障。</li>
<li>柔性事务中的服务模式：<ol>
<li>可查询操作：服务操作具有全局唯一的标识，操作唯一的确定的时间。</li>
<li>幂等操作：**重复调用多次产生的业务结果与调用一次产生的结果相同。**一是通过业务操作实现幂等性，二是系统缓存所有请求与处理的结果，最后是检测到重复请求之后，自动返回之前的处理结果。</li>
<li>TCC操作：Try阶段，尝试执行业务，完成所有业务的检查，实现一致性；预留必须的业务资源，实现准隔离性。Confirm阶段：真正的去执行业务，不做任何检查，仅适用Try阶段预留的业务资源，Confirm操作还要满足幂等性。Cancel阶段：取消执行业务，释放Try阶段预留的业务资源，Cancel操作要满足幂等性。TCC与2PC(两阶段提交)协议的区别：TCC位于业务服务层而不是资源层，TCC没有单独准备阶段，Try操作兼备资源操作与准备的能力，TCC中Try操作可以灵活的选择业务资源，锁定粒度。TCC的开发成本比2PC高。实际上TCC也属于两阶段操作，但是TCC不等同于2PC操作。</li>
<li>可补偿操作：Do阶段：真正的执行业务处理，业务处理结果外部可见。Compensate阶段：抵消或者部分撤销正向业务操作的业务结果，补偿操作满足幂等性。约束：补偿操作在业务上可行，由于业务执行结果未隔离或者补偿不完整带来的风险与成本可控。实际上，TCC的Confirm和Cancel操作可以看做是补偿操作。</li>
</ol>
</li>
</ul>
<h1 id="二、柔性事务解决方案架构"><a href="#二、柔性事务解决方案架构" class="headerlink" title="二、柔性事务解决方案架构"></a>二、柔性事务解决方案架构</h1><blockquote>
<p>在电商领域等互联网场景下，传统的事务在数据库性能和处理能力上都暴露出了瓶颈。柔性事务有两个特性：基本可用和柔性状态。所谓基本可用是指分布式系统出现故障的时候允许损失一部分的可用性。柔性状态是指允许系统存在中间状态，这个中间状态不会影响系统整体的可用性，比如数据库读写分离的主从同步延迟等。柔性事务的一致性指的是最终一致性。</p>
</blockquote>
<h2 id="（一）、基于可靠消息的最终一致性方案概述"><a href="#（一）、基于可靠消息的最终一致性方案概述" class="headerlink" title="（一）、基于可靠消息的最终一致性方案概述"></a>（一）、基于可靠消息的最终一致性方案概述</h2><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/xyingtao/blogimage/raw/master/img/1746373-20190720004658595-587546685.png" alt="img"></p>
<ul>
<li>实现：业务处理服务在业务事务提交之前，向<code>实时消息服务</code>请求发送消息，实时消息服务只记录消息数据，而不是真正的发送。业务处理服务在业务事务提交之后，向实时消息服务确认发送。只有在得到确认发送指令后，实时消息服务才会真正发送。</li>
<li>消息：业务处理服务在业务事务回滚后，向实时消息服务取消发送。消息发送状态确认系统定期找到<strong>未确认发送</strong>或者<strong>回滚发送</strong>的消息，向业务处理服务询问消息状态，业务处理服务根据消息ID或者消息内容确认该消息是否有效。被动方的处理结果不会影响主动方的处理结果，被动方的消息处理操作是<strong>幂等操作</strong>。</li>
<li>成本：可靠的消息系统建设成本，一次消息发送需要两次请求，业务处理服务需要实现消息状态回查接口。</li>
<li>优点：消息数据独立存储，独立伸缩，降低业务系统和消息系统之间的耦合。对最终一致性时间敏感度较高，降低业务被动方的实现成本。兼容所有实现JMS标准的MQ中间件，确保业务数据可靠的前提下，实现业务的最终一致性，理想状态下是准实时的一致性。</li>
</ul>
<h2 id="（二）、TCC事务补偿型方案"><a href="#（二）、TCC事务补偿型方案" class="headerlink" title="（二）、TCC事务补偿型方案"></a>（二）、TCC事务补偿型方案</h2><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/xyingtao/blogimage/raw/master/img/1746373-20190720004716218-1490757197.png" alt="img"></p>
<ul>
<li>实现：一个完整的业务活动由<strong>一个主业务</strong>服务于<strong>若干的从业务</strong>服务组成。主业务服务负责发起并完成整个业务活动。从业务服务提供TCC型业务操作。业务活动管理器控制业务活动的一致性，它登记业务活动的操作，并在业务活动提交时确认所有的TCC型操作的Confirm操作，在业务活动取消时调用所有TCC型操作的Cancel操作。</li>
<li>成本：实现TCC操作的成本较高，业务活动结束的时候Confirm和Cancel操作的执行成本。业务活动的日志成本。</li>
<li>使用范围：强隔离性，严格一致性要求的业务活动。适用于<strong>执行时间较短的业务</strong>，比如处理账户或者收费等等。</li>
<li>特点：不与具体的服务框架耦合，位于业务服务层，而不是资源层，可以灵活的选择业务资源的锁定粒度。TCC里对每个服务资源操作的是本地事务，数据被锁住的时间短，可扩展性好，可以说是为独立部署的SOA服务而设计的。</li>
</ul>
<h2 id="（三）、最大努力通知型"><a href="#（三）、最大努力通知型" class="headerlink" title="（三）、最大努力通知型"></a>（三）、最大努力通知型</h2><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/xyingtao/blogimage/raw/master/img/1746373-20190720004740659-943326129.png" alt="img"></p>
<ul>
<li>实现：业务活动的主动方在完成处理之后向业务活动的被动方发送消息，允许消息丢失。业务活动的被动方根据定时策略，向业务活动的主动方查询，恢复丢失的业务消息。</li>
<li>约束：被动方的处理结果不影响主动方的处理结果。</li>
<li>成本：业务查询与校对系统的建设成本。</li>
<li>使用范围：对业务最终一致性的<strong>时间敏感度低</strong>。跨企业的业务活动。</li>
<li>特点：业务活动的主动方在完成业务处理之后，向业务活动的被动方发送通知消息。主动方可以设置时间阶梯通知规则，在通知失败后按规则重复通知，知道通知N次后不再通知。主动方提供校对查询接口给被动方按需校对查询，用户恢复丢失的业务消息。</li>
<li>适用范围：银行通知，商户通知。</li>
</ul>
<h1 id="三、基于可靠消息的最终一致性方案详解"><a href="#三、基于可靠消息的最终一致性方案详解" class="headerlink" title="三、基于可靠消息的最终一致性方案详解"></a>三、基于可靠消息的最终一致性方案详解</h1><h2 id="（一）、消息发送一致性"><a href="#（一）、消息发送一致性" class="headerlink" title="（一）、消息发送一致性"></a>（一）、消息发送一致性</h2><p>消息中间件在分布式系统中的核心作用就是异步通讯、应用解耦和并发缓冲（也叫作流量削峰）。在分布式环境下，需要通过网络进行通讯，就引入了数据传输的不确定性，也就是CAP理论中的分区容错性。</p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/xyingtao/blogimage/raw/master/img/1746373-20190720004757446-2140390464.png" alt="img"></p>
<p>消息发送一致性是指产生消息的业务动作与消息发送一致，也就是说如果业务操作成功，那么由这个业务操作所产生的消息一定要发送出去，否则就丢失。</p>
<blockquote>
<p>处理方式一</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">completeOrderService</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="comment">// 处理订单</span></span><br><span class="line">	order.process();</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 发送会计原始凭证消息</span></span><br><span class="line">	pipe.sendAccountingVouchetMessage();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的情况中，如果业务操作成功，执行的消息发送之前应用发生故障，消息发送不出去，导致消息丢失，将会产生订单系统与会计系统的数据不一致。如果消息系统或者网络异常，也会导致消息发送不出去，也会造成数据不一致。</p>
<blockquote>
<p>处理方式二</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">completeOrderService</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="comment">// 发送会计原始凭证消息</span></span><br><span class="line">	pipe.sendAccountingVouchetMessage();</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 处理订单</span></span><br><span class="line">	order.process();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果将上面的两个操作调换一下顺序，这种情况就会更加不可控了，消息发出去了业务订单可能会失败，会造成订单系统与业务系统的数据不一致。那么JMS标准中的XA协议是否可以保障发送的一致性？</p>
<ul>
<li><p>JMS协议标准的API中，有很多以XA开头的接口，其实就是前面讲到的支持XA协议（基于两阶段提交协议）的全局事务型接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">XAConnection.<span class="keyword">class</span></span><br><span class="line"><span class="title class_">XAConnectionFactory</span>.<span class="keyword">class</span></span><br><span class="line"><span class="title class_">XAQueueConnection</span>.<span class="keyword">class</span></span><br><span class="line"><span class="title class_">XAQueueConnectionFactory</span>.<span class="keyword">class</span></span><br><span class="line"><span class="title class_">XASession</span>.<span class="keyword">class</span></span><br><span class="line"><span class="title class_">XATopicConnection</span>.<span class="keyword">class</span></span><br><span class="line"><span class="title class_">XATopicConnectionFactory</span>.<span class="keyword">class</span></span><br><span class="line"><span class="title class_">XATopicSession</span>.class</span><br></pre></td></tr></table></figure>
</li>
<li><p>JMS中的XA系列的接口可以提供分布式事务的支持。但是引用XA方式的分布式事务，就会带来很多局限性。</p>
<ol>
<li>要求业务操作的资源必须支持XA协议，但是并不是所有的资源都支持XA协议。</li>
<li>两阶段提交协议的成本。</li>
<li>持久化成本等DTP模型的局限性，例如：全局锁定、成本高、性能低。</li>
<li>使用XA协议违背了柔性事务的初衷。</li>
</ol>
</li>
</ul>
<h2 id="（二）、保证消息一致的变通做法"><a href="#（二）、保证消息一致的变通做法" class="headerlink" title="（二）、保证消息一致的变通做法"></a>（二）、保证消息一致的变通做法</h2><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/xyingtao/blogimage/raw/master/img/1746373-20190720004823492-236150964.png" alt="img"></p>
<ol>
<li>发送消息：主动方现将应用把消息发给消息中间件，消息状态标记为“待确认”状态。</li>
<li>消息中间件收到消息后，把消息持久化到消息存储中，但是并不影响被动方投递消息。</li>
<li>消息中间件返回消息持久化结果，主动方根据返回的结果进行判断如何进行业务操作处理：<ol>
<li>失败：放弃执行业务操作处理，结束，必要时向上层返回处理结果。</li>
<li>成功：执行业务操作处理。</li>
</ol>
</li>
<li>业务操作完成后，把业务操作结果返回给消息中间件。</li>
<li>消息中间件收到业务操作结构后，根据业务结果进行处理：<ol>
<li>失败：删除消息存储中的消息，结束。</li>
<li>成功：更新消息存储中的消息状态为“待发送”，然后执行消息投递。</li>
</ol>
</li>
<li>前面的正向流程都成功之后，向被动方应用投递消息。</li>
</ol>
<p>但是在上面的处理流程中，任何一个环节都有可能出现问题。</p>
<h2 id="（三）、常规MQ消息处理流程和特点"><a href="#（三）、常规MQ消息处理流程和特点" class="headerlink" title="（三）、常规MQ消息处理流程和特点"></a>（三）、常规MQ消息处理流程和特点</h2><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/xyingtao/blogimage/raw/master/img/1746373-20190720004838981-1674998867.png" alt="img"></p>
<ul>
<li>常规的MQ队列处理流程无法实现消息的一致性。</li>
<li>投递消息的本质就是消息消费，可以细化。</li>
</ul>
<h2 id="（四）、消息重复发送问题和业务接口幂等性设计"><a href="#（四）、消息重复发送问题和业务接口幂等性设计" class="headerlink" title="（四）、消息重复发送问题和业务接口幂等性设计"></a>（四）、消息重复发送问题和业务接口幂等性设计</h2><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/xyingtao/blogimage/raw/master/img/1746373-20190720004908806-270573655.png" alt="img"></p>
<p>对于未确认的消息，采用按规则重新投递的方式进行处理。对于以上流程，消息重复发送会导致业务处理接口出现重复调用的问题。消息消费过程中消息重复发送的主要原因就是消费者成功接收处理完消息后，消息中间件没有及时更新投递状态导致的。如果允许消息重复发送，那么消费方应该实现业务接口的幂等性设计。</p>
<h2 id="（五）、本地消息服务方案"><a href="#（五）、本地消息服务方案" class="headerlink" title="（五）、本地消息服务方案"></a>（五）、本地消息服务方案</h2><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/xyingtao/blogimage/raw/master/img/1746373-20190720004928257-550738452.png" alt="img"></p>
<ul>
<li>实现思路：<ol>
<li>主动方应用系统通过业务操作完成业务数据的操作，在准备发送消息的时候将消息存储在主动方应用系统一份，另一份发送到实时消息服务</li>
<li>被动方应用系统监听实时消息系统中的消息，当被动方完成消息处理后通过调用主动方接口完成消息确认</li>
<li>主动方接收到消息确认以后删除消息数据。</li>
<li>通过消息查询服务查询到消息被接收之后再规定的时间内没有返回ACK确认消息就通过消息恢复系统重新发送消息。</li>
</ol>
</li>
<li>优点：<ol>
<li>消息的时效性比较高</li>
<li>从应用设计的角度实现了消息数据的可靠性，消息数据的可靠性不依赖于MQ中间件，弱化了对MQ中间件特性的依赖。</li>
<li>方案轻量级，容易实现。</li>
</ol>
</li>
<li>缺点：<ol>
<li>与具体的业务场景绑定，耦合性强，不可以共用。</li>
<li>消息数据与业务数据同步，占用业务系统资源。</li>
<li>业务系统在使用关系型数据库的情况下消息服务性能会受到关系型数据库的并发性能限制。</li>
</ol>
</li>
</ul>
<h2 id="（六）、独立消息服务方案"><a href="#（六）、独立消息服务方案" class="headerlink" title="（六）、独立消息服务方案"></a>（六）、独立消息服务方案</h2><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/xyingtao/blogimage/raw/master/img/1746373-20190720004948986-403677262.png" alt="img"></p>
<ul>
<li>实现思路：<ol>
<li>预发送消息：主动方应用系统预发送消息，由消息服务子系统存储消息，如果存储失败，那么也就无法进行业务操作。如果返回存储成功，然后执行业务操作。</li>
<li>执行业务操作：执行业务操作如果成功的时候，将业务操作执行成功的状态发送到消息服务子系统。消息服务子系统修改消息的标识为“可发送”状态。</li>
<li>发送消息到实时消息服务：当消息的状态发生改变的时候，立刻将消息发送到实时消息服务中。接下来，消息将会被消息业务的消费端监听到，然后被消费。</li>
<li>消息状态子系统：相当于定时任务系统，在消息服务子系统中定时查找确认超时的消息，在主动方应用系统中也去定时查找没有处理成功的任务，进行相应的处理。</li>
<li>消息消费：当消息被消费的时候，向实时消息服务发送ACK，然后实时消息服务删除消息。同时调用消息服务子系统修改消息为“被消费”状态。</li>
<li>消息恢复子系统：当消费方返回消息的时候，由于网络中断等其他原因导致消息没有及时确认，那么需要消息恢复子系统定时查找出在消息服务子系统中没有确认的消息。将没有被确认的消息放到实时消息服务中，进行重做，因为被动方应用系统的接口是幂等的。</li>
</ol>
</li>
<li>优点：<ol>
<li>消息服务独立部署，独立维护，独立伸缩。</li>
<li>消息存储可以按需选择不同的数据库来集成实现。</li>
<li>消息服务可以被相同的的使用场景使用，降低重复建设服务的成本。</li>
<li>从分布式服务应用设计开发角度实现了消息数据的可靠性，消息数据的可靠性不依赖于MQ中间件，弱化了对MQ中间件特性的依赖。</li>
<li>降低了业务系统与消息系统之间的耦合，有利于系统的扩展维护。</li>
</ol>
</li>
<li>缺点：<ol>
<li>一次消息发送需要两次请求。</li>
<li>主动方应用系统需要实现业务操作状态的校验与查询接口。</li>
</ol>
</li>
</ul>
<h2 id="（七）、消息服务子系统的设计实现"><a href="#（七）、消息服务子系统的设计实现" class="headerlink" title="（七）、消息服务子系统的设计实现"></a>（七）、消息服务子系统的设计实现</h2><p>示例消息数据表：</p>
<table>
<thead>
<tr>
<th align="center">名称</th>
<th align="center">数据类型</th>
<th align="center">允许空</th>
<th align="center">默认值</th>
<th align="center">属性</th>
<th align="center">释义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">uuid</td>
<td align="center">varchar(50)</td>
<td align="center">No</td>
<td align="center">—</td>
<td align="center">unique</td>
<td align="center">UUID</td>
</tr>
<tr>
<td align="center">version</td>
<td align="center">int(11)</td>
<td align="center">No</td>
<td align="center">0</td>
<td align="center">—</td>
<td align="center">版本号</td>
</tr>
<tr>
<td align="center">editer</td>
<td align="center">varchar(100)</td>
<td align="center">Yes</td>
<td align="center">NULL</td>
<td align="center">—</td>
<td align="center">修改者</td>
</tr>
<tr>
<td align="center">creater</td>
<td align="center">varchar(100)</td>
<td align="center">Yes</td>
<td align="center">NULL</td>
<td align="center">—</td>
<td align="center">创建者</td>
</tr>
<tr>
<td align="center">edit_time</td>
<td align="center">datetime</td>
<td align="center">Yes</td>
<td align="center">0000-00-00 00:00:00</td>
<td align="center">—</td>
<td align="center">最后修改时间</td>
</tr>
<tr>
<td align="center">create_time</td>
<td align="center">datetime</td>
<td align="center">No</td>
<td align="center">0000-00-00 00:00:00</td>
<td align="center">—</td>
<td align="center">创建时间</td>
</tr>
<tr>
<td align="center">msg_id</td>
<td align="center">varchar(50)</td>
<td align="center">No</td>
<td align="center">—</td>
<td align="center">—</td>
<td align="center">消息ID</td>
</tr>
<tr>
<td align="center">msg_body</td>
<td align="center">longtext</td>
<td align="center">No</td>
<td align="center">—</td>
<td align="center">—</td>
<td align="center">消息内容</td>
</tr>
<tr>
<td align="center">msg_date_type</td>
<td align="center">varchar(50)</td>
<td align="center">Yes</td>
<td align="center">—</td>
<td align="center">—</td>
<td align="center">消息数据类型</td>
</tr>
<tr>
<td align="center">consumer_queue</td>
<td align="center">varchar(100)</td>
<td align="center">No</td>
<td align="center">—</td>
<td align="center">—</td>
<td align="center">消费队列</td>
</tr>
<tr>
<td align="center">send_times</td>
<td align="center">int(6)</td>
<td align="center">No</td>
<td align="center">0</td>
<td align="center">—</td>
<td align="center">消息重发次数</td>
</tr>
<tr>
<td align="center">is_dead</td>
<td align="center">varchar(20)</td>
<td align="center">No</td>
<td align="center">—</td>
<td align="center">—</td>
<td align="center">是否死亡</td>
</tr>
<tr>
<td align="center">status</td>
<td align="center">varchar(20)</td>
<td align="center">No</td>
<td align="center">—</td>
<td align="center">—</td>
<td align="center">状态</td>
</tr>
<tr>
<td align="center">remark</td>
<td align="center">varchar(200)</td>
<td align="center">Yes</td>
<td align="center">—</td>
<td align="center">—</td>
<td align="center">备注</td>
</tr>
<tr>
<td align="center">field0</td>
<td align="center">varchar(200)</td>
<td align="center">Yes</td>
<td align="center">—</td>
<td align="center">—</td>
<td align="center">扩展字段0</td>
</tr>
<tr>
<td align="center">field1</td>
<td align="center">varchar(200)</td>
<td align="center">Yes</td>
<td align="center">—</td>
<td align="center">—</td>
<td align="center">扩展字段1</td>
</tr>
<tr>
<td align="center">field2</td>
<td align="center">varchar(200)</td>
<td align="center">Yes</td>
<td align="center">—</td>
<td align="center">—</td>
<td align="center">扩展字段2</td>
</tr>
</tbody></table>
<p>不积跬步，无以至千里；不积小流，无以成江河。</p>
<h1 id="分布式事务SEATA"><a href="#分布式事务SEATA" class="headerlink" title="分布式事务SEATA"></a>分布式事务SEATA</h1><p>alibaba提供的开源分布式事务解决方案 </p>
<p>Seata是一款开源的分布式事务解决方案,致力于提供高性能和简单易用的分布式事务服务.Seata将为用户提供了AT,TCC,SAGA和XA事务模式,为用户打造一站式的分布式解决方案.</p>
<h2 id="Seata术语"><a href="#Seata术语" class="headerlink" title="Seata术语"></a>Seata术语</h2><h4 id="TC-Transaction-Coordinator-事务协调者"><a href="#TC-Transaction-Coordinator-事务协调者" class="headerlink" title="TC (Transaction Coordinator) - 事务协调者"></a>TC (Transaction Coordinator) - 事务协调者</h4><p>维护全局和分支事务的状态，驱动全局事务提交或回滚。</p>
<h4 id="TM-Transaction-Manager-事务管理器"><a href="#TM-Transaction-Manager-事务管理器" class="headerlink" title="TM (Transaction Manager) - 事务管理器"></a>TM (Transaction Manager) - 事务管理器</h4><p>定义全局事务的范围：开始全局事务、提交或回滚全局事务。</p>
<h4 id="RM-Resource-Manager-资源管理器"><a href="#RM-Resource-Manager-资源管理器" class="headerlink" title="RM (Resource Manager) - 资源管理器"></a>RM (Resource Manager) - 资源管理器</h4><p>管理分支事务处理的资源，与TC交谈以注册分支事务和报告分支事务的状态，并驱动分支事务提交或回滚。</p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/xyingtao/blogimage/raw/master/img/image-20200901152708532.png" alt="image-20200901152708532"></p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/xyingtao/blogimage/raw/master/img/image-20200901152726511.png" alt="image-20200901152726511"></p>
<h2 id="使用seata"><a href="#使用seata" class="headerlink" title="使用seata"></a>使用seata</h2><ol>
<li>在每个微服务创建一个undo_log表</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `undo_log` (</span><br><span class="line">  `id` bigint(20) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `branch_id` bigint(20) NOT NULL,</span><br><span class="line">  `xid` varchar(100) NOT NULL,</span><br><span class="line">  `context` varchar(128) NOT NULL,</span><br><span class="line">  `rollback_info` longblob NOT NULL,</span><br><span class="line">  `log_status` int(11) NOT NULL,</span><br><span class="line">  `log_created` datetime NOT NULL,</span><br><span class="line">  `log_modified` datetime NOT NULL,</span><br><span class="line">  `ext` varchar(100) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`),</span><br><span class="line">  UNIQUE KEY `ux_undo_log` (`xid`,`branch_id`)</span><br><span class="line">) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>下载安装事务协调器 seata</li>
<li>导入依赖 spring-cloud-starter-alibaba-seata seata-all<ul>
<li>启动seata服务器</li>
<li>registy.conf :注册中心相关配置 指定nacos 服务中心</li>
<li>所有想要使用分布式事务的微服务都需要 使用seata代理其数据源</li>
<li>每一个服务都必须导入 两个conf文件 按要求修改file文件</li>
</ul>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class MySeataConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    DataSourceProperties dataSourceProperties;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public DataSource dataSource(DataSourceProperties dataSourceProperties)&#123;</span><br><span class="line">        HikariDataSource dataSource = dataSourceProperties.initializeDataSourceBuilder().type(HikariDataSource.class).build();</span><br><span class="line">        if (StringUtils.hasText(dataSourceProperties.getName()))&#123;</span><br><span class="line">            dataSource.setPoolName(dataSourceProperties.getName());</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        return new DataSourceProxy(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><p>启动测试分布式事务</p>
</li>
<li><p>给分布式大事务入口标注@GlobalTransactional</p>
<p>每一个远程小事务 标注 transactional</p>
</li>
</ol>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项:"></a>注意事项:</h3><ul>
<li>file.conf 的 service.vgroup_mapping 配置必须和<code>spring.application.name</code>一致</li>
</ul>
<p>在 <code>org.springframework.cloud:spring-cloud-starter-alibaba-seata</code>的<code>org.springframework.cloud.alibaba.seata.GlobalTransactionAutoConfiguration</code>类中，默认会使用 <code>$&#123;spring.application.name&#125;-fescar-service-group</code>作为服务名注册到 Seata Server上，如果和<code>file.conf</code>中的配置不一致，会提示 <code>no available server to connect</code>错误</p>
<p>也可以通过配置 <code>spring.cloud.alibaba.seata.tx-service-group</code>修改后缀，但是必须和<code>file.conf</code>中的配置保持一致</p>
<p>资料参考:尚硅谷</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">樱桃先生</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/posts/cdcc4eae/">http://example.com/posts/cdcc4eae/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://example.com" target="_blank">樱桃先生</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E4%BA%8B%E5%8A%A1/">事务</a><a class="post-meta__tags" href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F/">分布式</a><a class="post-meta__tags" href="/tags/seata/">seata</a></div><div class="post-share"><div class="social-share" data-image="https://gitee.com/xyingtao/blogimage/raw/master/img/分布式.jpg" data-sites="wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赞助</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://s2.loli.net/2022/08/21/Ay5sujrkH1nLTwW.jpg" target="_blank"><img class="post-qr-code-img" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2022/08/21/Ay5sujrkH1nLTwW.jpg" alt="Wechat"/></a><div class="post-qr-code-desc">Wechat</div></li></ul></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/posts/b5f946b9/" title="Redis五大数据类型"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/xyingtao/blogimage/raw/master/img/redis.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Redis五大数据类型</div></div><div class="info-2"><div class="info-item-1">Redis五大数据类型Key +   string set list hash zset  通用操作指令12345678910111213141516171819#查询当前库的所有键keys * #判断某个键是否存在exists &lt;key&gt; #查看键的类型type &lt;key&gt;#删除某个键del &lt;key&gt;#设置键值对的过期时间 单位:秒expire &lt;key&gt; &lt;seconds&gt;#查看还有多少秒过期 -1永不过期 -2已过期ttl &lt;key&gt;#查看当前数据库key的数量dbsize#清空当前库Flushdb#通杀全部库Flushall    String String是Redis最基本的类型,可以理解成与Memcached一模一样的类型,一个key 对应一个value String类型是二进制安全的,意味着redis的string可以包含任何数据.比如jpg图片或者序列化的对象 String类型是redis最基本的数据类型,一个redis中,字符串value最多可以是512M  基本操作指令123456789...</div></div></div></a><a class="pagination-related" href="/posts/66c89092/" title="消息队列RabbitMQ"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/xyingtao/blogimage/raw/master/img/RabbitMQ.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">消息队列RabbitMQ</div></div><div class="info-2"><div class="info-item-1">RabbitMQ消息队列MQ概述MQ全称Message Queue(消息队列),是在消息的传输过程中保存消息的容器.多用于分布式系统之间进行通信   分布式系统通信方式: 直接远程调用  借助第三方完成间接通信    MQ的优势: 应用解耦 异步提速 削峰填谷  MQ的劣势: 系统可用性降低 AB系统没问题 还需要保证MQ没问题 引入的外部依赖越多,系统稳定性越差  系统复杂度提高 如何保证消息没有重复消费 没有丢失 保证顺序性  一致性问题 给BCD三个系统 如果其中一个处理失败如何处理   使用MQ的前提: 生产者不需要从消费者获得反馈 容许短暂的不一致性 使用收益超过加入成本  RabbitMQ简介常用的MQ产品,各有侧重  RabbitMQ是一个由erlang开发的AMQP(Advance Message Queue Protocol)的开源实现 AMQP: 高级消息队列协议,是一个网络协议,是应用层协议的一个开放标准,为面向消息的中间件设计.基于此协议的客户端与消息中间件可传递消息,并不 受客户端&#x2F;中间件不同产品,不同开发语言的限制.2006年 AMQP规范发...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/posts/9421881e/" title="AS&#x2F;400事务和日志"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/Xyingtao/blogimage/raw/master/img/AS400.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2020-10-12</div><div class="info-item-2">AS&#x2F;400事务和日志</div></div><div class="info-2"><div class="info-item-1">事务COMMIT 提交当前事务．所有事务的更改都将为其他事务可见，而且保证当崩溃发生时的可持续性。在程序中经常使用 COMMMIT 来控制事物处理的完整性，保证在发生异常的情况下数据的完整性和正确性。访问数据库文件时使用 COMMIT&#x2F;ROLBK，可以确保对数据库文件操作的一致性：全部数据库文件操作都是成功的 COMMIT 提交；全部数据库文件操作都是无效的 ROLBK 回滚. 用这种方法，从而保证了数据库文件的完整性；另外，可以把一组操作当作一个单元来处理。举个实际的例子，如果程序中，以修改的方式声明了四个文件 A、B、C、D，其中 A、B、C 都使用了 COMMIT 关键字，而 D 未使用 COMMIT 关键字；在程序执行过程中，首先更改了 A、B、D 的值在接下的处理中，如果业务流程判断，逻辑有误，不再执行，此时可以进行回滚操作，此时 A、B 的数据恢复成为修改之前的数值；D 的数据，因为在声明文件时未使用 COMMIT 关键字，所以回滚操作对它无效，即 D 的数据仍然保持修改之后的值；而如果业务流程判断正常，程序顺利执行完毕，此时需要进行一次确认操作（COMMI...</div></div></div></a><a class="pagination-related" href="/posts/23821d49/" title="分布式-CAP定理"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/xyingtao/blogimage/raw/master/img/分布式.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2020-09-12</div><div class="info-item-2">分布式-CAP定理</div></div><div class="info-2"><div class="info-item-1">cap理论一、什么是分布式系统拿一个最简单的例子，就比如说我们的图书管理系统。之前的系统包含了所有的功能，比如用户注册登录、管理员功能、图书借阅管理等。这叫做集中式系统。也就是一个人干了好几件事。 后来随着功能的增多，用户量也越来越大。集中式系统维护太麻烦，拓展性也不好。于是就考虑着把这些功能分开。通俗的理解就是原本需要一个人干的事，现在分给n个人干，各自干各自的，最终取得和一个人干的效果一样。 稍微正规一点的定义就是：一个业务分拆多个子业务，部署在不同的服务器上。 然后通过一定的通信协议，能够让这些子业务之间相互通信。 既然分给了n个人，那就涉及到这些人的沟通交流协作问题。想要去解决这些问题，就需要先聊聊分布式系统中的CAP理论。千万不要被这个看起来高大上的概念迷惑住。 二、简单的概述一下CAP理论指的是一个分布式系统最多只能同时满足一致性（Consistency）、可用性（Availability）和分区容错性（Partition tolerance）这三项中的两项。  1、一个小例子首先我们看一张图。  现在网络中有两个节点N1和N2，他们之间网络可以连通，N1中有一个应用...</div></div></div></a><a class="pagination-related" href="/posts/164e7d82/" title="Session共享问题"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://ytblogpic.oss-cn-guangzhou.aliyuncs.com/blog-common.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2020-08-21</div><div class="info-item-2">Session共享问题</div></div><div class="info-2"><div class="info-item-1">Session共享问题session就是服务器里的一个内存数据  Session共享问题分布式下session共享问题  不同域名不能共享 同一个服务,复制多份,session不同步问题 不同服务,session不能共享  Session共享解决session复制 优点:  web-server(Tomcat)原生支持,只需要修改配置文件  缺点  session同步需要数据传输,占用大量网络带宽,降低服务器群的业务处理能力 任意一台web-server保存的数据都是所有web-server的session总和,受到内存限制无法水平拓展更多server 大型分布式集群情况下,由于所有的web-server都全量保存数据,所以不可取  客户端存储 优点  服务器不需要存储sessio,用户保存自己的session信息到cookie中.节省服务端资源  缺点  都是缺点,基本不可能使用 每次http请求,携带用户cookie中的完整信息,浪费网络带宽 session数据放在cookie中,cookie有长度限制4k,不能保存大量信息 session数据放在cookie中,存在泄漏,篡...</div></div></div></a><a class="pagination-related" href="/posts/63f0196d/" title="接口幂等性问题"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/xyingtao/blogimage/raw/master/img/分布式.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2020-09-13</div><div class="info-item-2">接口幂等性问题</div></div><div class="info-2"><div class="info-item-1">接口幂等性订单防止重复提交 网络不好 用户点击多次 什么是幂等性用户对于同一操作发起的一次请求或者多次请求的结果是一致的 不会因为多次点击产生副作用 比如说支付场景 用户购买了商品支付扣款成功 但是返回结果的时候网络异常 这时候钱 已经扣掉了 再次点击会进行二次扣款…这就没有保证接口的幂等性 那些情况需要防止用户多次点击按钮 用户页面回退再次提交 微服务相互调用  由于网络问题导致请求失败 feign触发重试机制 其它业务情况 什么情况下需要幂等以sql为例子 查询 删除 操作大部分是天然的幂等性 因为在第一次的时候已经删除成功了 叠加状态  每次执行结果都不一样则不是幂等性 幂等性解决方案 索引 订单号 唯一 举例:五种方案令牌机制 ytmall商城项目采用这个方案  存在问题: 如果业务执行后才删令牌 令牌仍然有可能多次进入  如果先删令牌 保证获取令牌 对比 删除 必须是 原子性的  可以在redis 使用lua脚本完成这个原子操作操作 1if redis.call(&#x27;get&#x27;,KEY[1]) == ARGV[1] then return redis.c...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2022/08/20/hk9Zvq4YRsIcnrw.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">樱桃先生</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">78</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">65</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">21</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://ytblogpic.oss-cn-guangzhou.aliyuncs.com/typoraWechat.jpeg"><i class="fab fa-weixin"></i><span>加为好友</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎光临樱桃先生的博客🍒～</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E5%89%8D%E5%A5%8F"><span class="toc-number">1.</span> <span class="toc-text">一、分布式事务前奏</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E6%9F%94%E6%80%A7%E4%BA%8B%E5%8A%A1%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E6%9E%B6%E6%9E%84"><span class="toc-number">2.</span> <span class="toc-text">二、柔性事务解决方案架构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%88%E4%B8%80%EF%BC%89%E3%80%81%E5%9F%BA%E4%BA%8E%E5%8F%AF%E9%9D%A0%E6%B6%88%E6%81%AF%E7%9A%84%E6%9C%80%E7%BB%88%E4%B8%80%E8%87%B4%E6%80%A7%E6%96%B9%E6%A1%88%E6%A6%82%E8%BF%B0"><span class="toc-number">2.1.</span> <span class="toc-text">（一）、基于可靠消息的最终一致性方案概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%88%E4%BA%8C%EF%BC%89%E3%80%81TCC%E4%BA%8B%E5%8A%A1%E8%A1%A5%E5%81%BF%E5%9E%8B%E6%96%B9%E6%A1%88"><span class="toc-number">2.2.</span> <span class="toc-text">（二）、TCC事务补偿型方案</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%88%E4%B8%89%EF%BC%89%E3%80%81%E6%9C%80%E5%A4%A7%E5%8A%AA%E5%8A%9B%E9%80%9A%E7%9F%A5%E5%9E%8B"><span class="toc-number">2.3.</span> <span class="toc-text">（三）、最大努力通知型</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E5%9F%BA%E4%BA%8E%E5%8F%AF%E9%9D%A0%E6%B6%88%E6%81%AF%E7%9A%84%E6%9C%80%E7%BB%88%E4%B8%80%E8%87%B4%E6%80%A7%E6%96%B9%E6%A1%88%E8%AF%A6%E8%A7%A3"><span class="toc-number">3.</span> <span class="toc-text">三、基于可靠消息的最终一致性方案详解</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%88%E4%B8%80%EF%BC%89%E3%80%81%E6%B6%88%E6%81%AF%E5%8F%91%E9%80%81%E4%B8%80%E8%87%B4%E6%80%A7"><span class="toc-number">3.1.</span> <span class="toc-text">（一）、消息发送一致性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%88%E4%BA%8C%EF%BC%89%E3%80%81%E4%BF%9D%E8%AF%81%E6%B6%88%E6%81%AF%E4%B8%80%E8%87%B4%E7%9A%84%E5%8F%98%E9%80%9A%E5%81%9A%E6%B3%95"><span class="toc-number">3.2.</span> <span class="toc-text">（二）、保证消息一致的变通做法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%88%E4%B8%89%EF%BC%89%E3%80%81%E5%B8%B8%E8%A7%84MQ%E6%B6%88%E6%81%AF%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B%E5%92%8C%E7%89%B9%E7%82%B9"><span class="toc-number">3.3.</span> <span class="toc-text">（三）、常规MQ消息处理流程和特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%88%E5%9B%9B%EF%BC%89%E3%80%81%E6%B6%88%E6%81%AF%E9%87%8D%E5%A4%8D%E5%8F%91%E9%80%81%E9%97%AE%E9%A2%98%E5%92%8C%E4%B8%9A%E5%8A%A1%E6%8E%A5%E5%8F%A3%E5%B9%82%E7%AD%89%E6%80%A7%E8%AE%BE%E8%AE%A1"><span class="toc-number">3.4.</span> <span class="toc-text">（四）、消息重复发送问题和业务接口幂等性设计</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%88%E4%BA%94%EF%BC%89%E3%80%81%E6%9C%AC%E5%9C%B0%E6%B6%88%E6%81%AF%E6%9C%8D%E5%8A%A1%E6%96%B9%E6%A1%88"><span class="toc-number">3.5.</span> <span class="toc-text">（五）、本地消息服务方案</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%88%E5%85%AD%EF%BC%89%E3%80%81%E7%8B%AC%E7%AB%8B%E6%B6%88%E6%81%AF%E6%9C%8D%E5%8A%A1%E6%96%B9%E6%A1%88"><span class="toc-number">3.6.</span> <span class="toc-text">（六）、独立消息服务方案</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%88%E4%B8%83%EF%BC%89%E3%80%81%E6%B6%88%E6%81%AF%E6%9C%8D%E5%8A%A1%E5%AD%90%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.7.</span> <span class="toc-text">（七）、消息服务子系统的设计实现</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1SEATA"><span class="toc-number">4.</span> <span class="toc-text">分布式事务SEATA</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Seata%E6%9C%AF%E8%AF%AD"><span class="toc-number">4.1.</span> <span class="toc-text">Seata术语</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#TC-Transaction-Coordinator-%E4%BA%8B%E5%8A%A1%E5%8D%8F%E8%B0%83%E8%80%85"><span class="toc-number">4.1.0.1.</span> <span class="toc-text">TC (Transaction Coordinator) - 事务协调者</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TM-Transaction-Manager-%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86%E5%99%A8"><span class="toc-number">4.1.0.2.</span> <span class="toc-text">TM (Transaction Manager) - 事务管理器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RM-Resource-Manager-%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E5%99%A8"><span class="toc-number">4.1.0.3.</span> <span class="toc-text">RM (Resource Manager) - 资源管理器</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8seata"><span class="toc-number">4.2.</span> <span class="toc-text">使用seata</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">4.2.1.</span> <span class="toc-text">注意事项:</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/4995/" title="顺德好友小聚"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://ytblogpic.oss-cn-guangzhou.aliyuncs.com/blog-common.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="顺德好友小聚"/></a><div class="content"><a class="title" href="/posts/4995/" title="顺德好友小聚">顺德好友小聚</a><time datetime="2023-05-07T13:56:00.000Z" title="发表于 2023-05-07 21:56:00">2023-05-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/51438/" title="旅游归来的周末"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://ytblogpic.oss-cn-guangzhou.aliyuncs.com/blog-common.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="旅游归来的周末"/></a><div class="content"><a class="title" href="/posts/51438/" title="旅游归来的周末">旅游归来的周末</a><time datetime="2023-05-06T05:56:00.000Z" title="发表于 2023-05-06 13:56:00">2023-05-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/34851/" title="与好友的广西之旅"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://ytblogpic.oss-cn-guangzhou.aliyuncs.com/blog-common.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="与好友的广西之旅"/></a><div class="content"><a class="title" href="/posts/34851/" title="与好友的广西之旅">与好友的广西之旅</a><time datetime="2023-05-02T04:30:00.000Z" title="发表于 2023-05-02 12:30:00">2023-05-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/53652/" title="项目管理笔记"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://ytblogpic.oss-cn-guangzhou.aliyuncs.com/blog-common.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="项目管理笔记"/></a><div class="content"><a class="title" href="/posts/53652/" title="项目管理笔记">项目管理笔记</a><time datetime="2022-08-28T04:30:00.000Z" title="发表于 2022-08-28 12:30:00">2022-08-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/53653/" title="项目管理笔记"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://ytblogpic.oss-cn-guangzhou.aliyuncs.com/typora%E6%88%AA%E5%B1%8F2022-08-27%2000.25.25.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="项目管理笔记"/></a><div class="content"><a class="title" href="/posts/53653/" title="项目管理笔记">项目管理笔记</a><time datetime="2022-08-28T04:30:00.000Z" title="发表于 2022-08-28 12:30:00">2022-08-28</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 By 樱桃先生</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.0</a></span></div><div class="footer_custom_text">一切都是最好的安排</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><div class="js-pjax"></div><script src="/js/jquery.min.js"></script><div class="aplayer no-destroy" data-id="5225697049" data-server="netease" data-type="playlist" data-fixed="true" data-autoplay="false" data-mini="true" data-lrctype="-1"> </div><script src="https://cdn.jsdelivr.net/gh/xiabo2/CDN@latest/fishes.js"></script><link rel="stylesheet" href="/css/utils.css"><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>