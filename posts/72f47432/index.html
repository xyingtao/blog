<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>垃圾回收 | 樱桃先生</title><meta name="author" content="樱桃先生"><meta name="copyright" content="樱桃先生"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="垃圾回收jdk14 CMS取消 ZGC迟早有一天替换掉G1 什么是垃圾 垃圾收集,不是Java语言的伴生产物.早在1960年,第一门开始使用内存动态分配和垃圾收集技术的Lisp语言诞生  关于垃圾收集有三个经典问题  哪些内存需要回收 什么时候回收 如何回收    垃圾收集机制是Java的招牌能力,极大地提高了开发效率.如今,垃圾收集几乎成为现代语言的标配,即使经过如此长时间的发展,Java的垃圾">
<meta property="og:type" content="article">
<meta property="og:title" content="垃圾回收">
<meta property="og:url" content="http://example.com/posts/72f47432/index.html">
<meta property="og:site_name" content="樱桃先生">
<meta property="og:description" content="垃圾回收jdk14 CMS取消 ZGC迟早有一天替换掉G1 什么是垃圾 垃圾收集,不是Java语言的伴生产物.早在1960年,第一门开始使用内存动态分配和垃圾收集技术的Lisp语言诞生  关于垃圾收集有三个经典问题  哪些内存需要回收 什么时候回收 如何回收    垃圾收集机制是Java的招牌能力,极大地提高了开发效率.如今,垃圾收集几乎成为现代语言的标配,即使经过如此长时间的发展,Java的垃圾">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://ytblogpic.oss-cn-guangzhou.aliyuncs.com/blog-common.png">
<meta property="article:published_time" content="2021-03-28T06:50:00.000Z">
<meta property="article:modified_time" content="2021-03-28T06:50:00.000Z">
<meta property="article:author" content="樱桃先生">
<meta property="article:tag" content="JVM">
<meta property="article:tag" content="垃圾回收">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://ytblogpic.oss-cn-guangzhou.aliyuncs.com/blog-common.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "垃圾回收",
  "url": "http://example.com/posts/72f47432/",
  "image": "https://ytblogpic.oss-cn-guangzhou.aliyuncs.com/blog-common.png",
  "datePublished": "2021-03-28T06:50:00.000Z",
  "dateModified": "2021-03-28T06:50:00.000Z",
  "author": [
    {
      "@type": "Person",
      "name": "樱桃先生",
      "url": "http://example.com"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/posts/72f47432/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '垃圾回收',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2022/08/20/hk9Zvq4YRsIcnrw.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">78</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">65</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">21</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/gallery/"><i class="fa-fw fas fa-camera"></i><span> 图库</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fas fa-comment-dots"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://ytblogpic.oss-cn-guangzhou.aliyuncs.com/blog-common.png);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">樱桃先生</span></a><a class="nav-page-title" href="/"><span class="site-name">垃圾回收</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/gallery/"><i class="fa-fw fas fa-camera"></i><span> 图库</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fas fa-comment-dots"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">垃圾回收</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-03-28T06:50:00.000Z" title="发表于 2021-03-28 14:50:00">2021-03-28</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-03-28T06:50:00.000Z" title="更新于 2021-03-28 14:50:00">2021-03-28</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%8A%80%E6%9C%AF/JVM/">JVM</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h1><p>jdk14 CMS取消 ZGC迟早有一天替换掉G1</p>
<h2 id="什么是垃圾"><a href="#什么是垃圾" class="headerlink" title="什么是垃圾"></a>什么是垃圾</h2><ul>
<li><p>垃圾收集,不是Java语言的伴生产物.早在1960年,第一门开始使用内存动态分配和垃圾收集技术的Lisp语言诞生</p>
</li>
<li><p>关于垃圾收集有三个经典问题</p>
<ul>
<li>哪些内存需要回收</li>
<li>什么时候回收</li>
<li>如何回收</li>
</ul>
</li>
<li><ul>
<li>垃圾收集机制是Java的招牌能力,极大地提高了开发效率.如今,垃圾收集几乎成为现代语言的标配,即使经过如此长时间的发展,Java的垃圾收集机制仍然在不断的演进,不同大小设备,不同特征的应用场景,对垃圾收集提出了新的挑战</li>
</ul>
</li>
<li><p><strong>什么是垃圾呢?</strong></p>
<ul>
<li>垃圾是指在运行程序中<code>没有任何指针指向</code>的对象 这个对象就是需要被回收的垃圾</li>
</ul>
</li>
<li><p>如果不及时对内存中的垃圾进行清理 那么这些垃圾对象所占用的内存空间就一直保留到应用程序结束 被保留的空间<strong>无法被其他对象使用</strong> 甚至可能导致<code>内存溢出</code></p>
</li>
</ul>
<h2 id="为什么需要GC"><a href="#为什么需要GC" class="headerlink" title="为什么需要GC?"></a>为什么需要GC?</h2><ul>
<li>对于高级语言来说,一个基本认知是如果不进行垃圾回收,内存迟早都会被消耗完,因为不断地分配内存空间而不进行回收,就好像不停地生产生活垃圾而从来不打扫一样</li>
<li>除了释放没用的对象,垃圾回收也可以清除内存里的纪录碎片.碎片整理将占用的堆内存存到堆的一端,以便JVM将整理出的内存分配给新的对象</li>
<li>随着应用程序所应付的业务越来越庞大,复杂,用户越来越多,没有GC就不能保证应用程序的正常进行.而经常造成STW的GC又跟不上实际的需求,所以才会不断地尝试GC进行优化</li>
</ul>
<h2 id="早期垃圾回收"><a href="#早期垃圾回收" class="headerlink" title="早期垃圾回收"></a>早期垃圾回收</h2><ul>
<li><p>在早期的C&#x2F;C++时代,垃圾回收基本上是手工进行的.开发人员可以使用new关键字进行内存申请,并使用delete关键字进行内存释放.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MibBridge *pBridge= <span class="keyword">new</span> <span class="title class_">cmBaseGroupBridge</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(pBridge-&gt;Register(kDestory)!=NO_ERROR)</span><br><span class="line">    delete pBridge;</span><br></pre></td></tr></table></figure>



<p>这种方式可以灵活控制内存释放的时间,但是会给开发人员带来频繁申请和释放内存的<strong>管理负担</strong>.倘若有一处内存区域由于程序员编码的问题忘记被回收,那么就会产生内存泄漏,垃圾对象永远无法被清除,随着系统运行时间的不断增长,垃圾对象所耗内存可能持续上升,直到出现内存溢出并造成应用程序崩溃</p>
</li>
</ul>
<h2 id="Java垃圾回收机制"><a href="#Java垃圾回收机制" class="headerlink" title="Java垃圾回收机制"></a>Java垃圾回收机制</h2><ul>
<li>自动内存管理,无需开发人员手动参与内存的分配与回收,这样降低<strong>内存泄漏和内存溢出</strong>的风险<ul>
<li>没有垃圾回收器,java也会跟cpp一样,各种悬垂指针,野指针,泄漏问题让你头疼不已</li>
</ul>
</li>
<li>自动内存管理机制,将程序员从繁重的内存管理中释放出来, 可以更专心地专注于业务开发</li>
</ul>
<p>对于java开发人员而言,自动内存管理就像是一个黑匣子,如果过度依赖于”自动”,那么这将会是一场灾难,最严重的就会弱化Java开发人员在程序出现内存溢出时定位问题和解决问题的能力</p>
<p>此时,了解JVM的自动内存分配和内存回收原理就显得非常重要,只有在真正了解JVM是如何管理内存后,我们才能够在遇见OutOfMemoryError时,快速地根据错误异常日志定位问题和解决问题</p>
<p>当需要排查各种内存溢出,内存泄漏问题的时,当垃圾收集成为系统达到更高并发量的瓶颈时,就必须对这些”自动化”的技术实施必要的监控和调节</p>
<h2 id="GC的作用区域-方法区-堆"><a href="#GC的作用区域-方法区-堆" class="headerlink" title="GC的作用区域 方法区 堆"></a>GC的作用区域 方法区 堆</h2><ul>
<li>垃圾回收器可以对年轻代进行回收,也可以对老年代回收,甚至是全堆和方法区的回收.<ul>
<li>其中Java堆是垃圾收集器的工作重点</li>
</ul>
</li>
<li>从次数上讲:<ul>
<li>频繁收集young区</li>
<li>较少收集Old区</li>
<li>基本不动Perm区</li>
</ul>
</li>
</ul>
<h1 id="垃圾回收相关算法"><a href="#垃圾回收相关算法" class="headerlink" title="垃圾回收相关算法"></a>垃圾回收相关算法</h1><h2 id="垃圾标记阶段的算法值引用计数算法"><a href="#垃圾标记阶段的算法值引用计数算法" class="headerlink" title="垃圾标记阶段的算法值引用计数算法"></a>垃圾标记阶段的算法值引用计数算法</h2><p>垃圾标记阶段:<strong>对象存活判断</strong></p>
<ul>
<li><p>在堆里存放着几乎所有的java对象实例 在GC执行垃圾回收之前 首先需要区分出内存中哪些是 存活对象 哪些是已经死亡的对象 只有标记为已经死亡的对象 GC才会在执行垃圾回收时候释放掉其所占用的内存空间 因此这个过程我们可以称为 <strong>垃圾标记阶段</strong></p>
</li>
<li><p>那么在JVM中究竟是如何标记一个死亡对象的呢?简单来说 当一个对象已经不再被任何存活对象继续引用时 就可以宣判为已经死亡</p>
</li>
<li><p>判断对象存活一般有两种方式:</p>
<ul>
<li><strong>引用计数算法</strong></li>
<li><strong>可达性分析算法</strong></li>
</ul>
</li>
</ul>
<h2 id="方式一-引用计数算法-Java不用"><a href="#方式一-引用计数算法-Java不用" class="headerlink" title="方式一:引用计数算法(Java不用)"></a>方式一:引用计数算法(Java不用)</h2><ul>
<li><p>引用计数算法比较简单 对每个对象保存一个整型的<strong>引用计数器属性</strong>用于记录对象被引用的情况</p>
</li>
<li><p>对于一个对象A 只要有任何一个对象引用了A 则A的引用计数器就加1 当引用失效时 引用计数器就减1,只要对象A的引用计数器的值为0 即表示对象A不可能再被使用 可进行回收</p>
</li>
<li><p>优点: 实现简单 垃圾对象容易辨识 判定<code>效率高</code>,回收没有<code>延迟性</code></p>
</li>
<li><p>缺点:</p>
<ul>
<li><p>它需要单独的字段存储计数器 这样的做法增加了<code>存储空间的开销</code></p>
</li>
<li><p>每次赋值需要更新计数器 伴随加法减法操作 这增加了<code>时间开销</code></p>
</li>
<li><p>引用计数器有一个严重的问题 即无法处理<code>循环引用</code>的情况</p>
<p>这时一条致命缺陷 导致在java的垃圾回收器中没有使用这类算法</p>
</li>
</ul>
</li>
</ul>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/xyingtao/blogimage/raw/master/image-20200623120536479.png" alt="image-20200623120536479"></p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/xyingtao/blogimage/raw/master/image-20200623120820609.png" alt="image-20200623120820609"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * -XX:+PrintGCDetails</span></span><br><span class="line"><span class="comment"> * 证明：java使用的不是引用计数算法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shkstart</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020 下午 2:38</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RefCountGC</span> &#123;</span><br><span class="line">    <span class="comment">//这个成员属性唯一的作用就是占用一点内存</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">byte</span>[] bigSize = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">5</span> * <span class="number">1024</span> * <span class="number">1024</span>];<span class="comment">//5MB</span></span><br><span class="line"></span><br><span class="line">    <span class="type">Object</span> <span class="variable">reference</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">RefCountGC</span> <span class="variable">obj1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RefCountGC</span>();</span><br><span class="line">        <span class="type">RefCountGC</span> <span class="variable">obj2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RefCountGC</span>();</span><br><span class="line"></span><br><span class="line">        obj1.reference = obj2;</span><br><span class="line">        obj2.reference = obj1;</span><br><span class="line"></span><br><span class="line">        obj1 = <span class="literal">null</span>;</span><br><span class="line">        obj2 = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//显式的执行垃圾回收行为</span></span><br><span class="line">        <span class="comment">//这里发生GC，obj1和obj2能否被回收？</span></span><br><span class="line">        System.gc();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>引用计数算法,是很多语言的资源回收选择,例如因人工智能而更加火热的Python,它更是同时支持引用技术和垃圾收集机制</li>
<li>具体哪种最优需要看场景,业界有大规模实践中仅保留引用计数机制,以提高吞吐量的尝试</li>
<li>Python如果解决循环引用?<ul>
<li>手动接触: 很好理解,就是在合适的时机,解除引用关系</li>
<li>使用弱引用weakref,weakref是Python提供的标准库,旨在解决循环引用</li>
</ul>
</li>
</ul>
<h2 id="方式二-可达性分析算法-根搜索算法-追踪性垃圾收集"><a href="#方式二-可达性分析算法-根搜索算法-追踪性垃圾收集" class="headerlink" title="方式二:可达性分析算法(根搜索算法 追踪性垃圾收集)"></a>方式二:可达性分析算法(根搜索算法 追踪性垃圾收集)</h2><ul>
<li>相较于引用计数算法而言 可达性分析算法不仅同样具备实现简单和执行高效特点 更重要的是该算法可以有效地解决在引用计数算法中<strong>循环引用</strong>的问题 防止<strong>内存泄漏</strong>的发生</li>
<li>相较于引用计数算法 这里的可达性分析就是java C#选择的 这种类型的垃圾收集通常也叫作<strong>追踪性垃圾收集</strong></li>
</ul>
<h3 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h3><p>GC Roots 就是一组必须活跃的引用</p>
<ul>
<li>可达性分析算法是以根<strong>对象集合</strong>为起始点 按照从上至下的方式搜索被根对象集合所连接的目标对象是否可达</li>
<li>使用可达性分析算法后 内存中的存活对象都会被根对象集合直接或者间接连接着 搜索走过的路径称为<code>引用链</code>(Reference chain)</li>
<li>如果目标对象没有任何引用链相连 则是不可达的 就意味着该对象已经死亡 可以标记为垃圾对象</li>
<li>在可达性分析算法中 只有能够被根对象集合直接或者间接连接的对象才是存活对象</li>
</ul>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/xyingtao/blogimage/raw/master/image-20200623122402743.png" alt="image-20200623122402743"></p>
<h3 id="GC-Roots-包括以下几类元素"><a href="#GC-Roots-包括以下几类元素" class="headerlink" title="GC Roots 包括以下几类元素"></a>GC Roots 包括以下几类元素</h3><ul>
<li><p>虚拟机<strong>栈</strong>中引用的对象</p>
<ul>
<li>比如 各个线程中被调用的方法中使用到的参数 局部变量等</li>
</ul>
</li>
<li><p><strong>本地方法栈</strong>内JNI(本地方法)引用的对象</p>
</li>
<li><p>方法区中<strong>类静态属性</strong>引用的对象</p>
<ul>
<li>比如 java类的引用类型静态变量</li>
</ul>
</li>
<li><p>方法区中 <strong>常量</strong>引用的对象</p>
<ul>
<li>比如 字符串常量池里的引用</li>
</ul>
</li>
<li><p>所有被<strong>同步锁 synchronized持有的对象</strong></p>
</li>
<li><p>Java<strong>虚拟机内部</strong>的引用</p>
<ul>
<li>基本数据类型对应的Class对象 一下常驻的异常对象 (如:NullPointerException OutOfMemoryError),系统类加载器</li>
</ul>
</li>
<li><p>反应java虚拟机内部情况的JMXBean JVMTI中注册的回调本地代码缓存等</p>
</li>
<li><p>除了这些固定的GC Roots集合以外,根据用户所选用的垃圾收集器以及当前回收的内存区域不同,还可以有其他对象”临时性”地加入 共同构成完整GC Roots集合.比如分代收集和局部回收(Partial GC)</p>
<ul>
<li>如果只针对Java堆中的某一块区域进行垃圾回收(比如:典型的只针对新生代),必须考虑到内存区域是虚拟机自己的实现细节,更不是孤立封闭的,这个区域的对象完全有可能被其他区域的对象所引用,这时候就需要一并将关联的区域对象也加入GC Roots集合中区考虑,才能保证可达性分析的准确性</li>
</ul>
</li>
<li><p>小技巧:</p>
<p>由于Root栈方式存放变量和指针,所以如果一个指针,它保存了堆内存里面的对象,但是自己又不存放在堆内存里面,那么它就是一个Root</p>
</li>
<li><p>如果要使用可达性分析算法来判断内存是否可回收,那么分析工作必须在一个能保障一致性的快照中进行.这点不满足的话分析结果的准确性就无法保证</p>
</li>
<li><p>这点也是导致GC进行时必须”Stop The World”的一个重要原因</p>
<ul>
<li>即使是号称(几乎)不会发生停顿的CMS收集器中,枚举根节点时也是必须要停顿的</li>
</ul>
</li>
</ul>
<p>CMS第一个低延迟的垃圾回收器</p>
<h2 id="对象的finalization"><a href="#对象的finalization" class="headerlink" title="对象的finalization"></a>对象的finalization</h2><ul>
<li><p>Java语言提供了对象终止机制来允许开发人员提供对象被销毁之前的自定义处理逻辑</p>
</li>
<li><p>当垃圾回收器发现没有引用指向一个对象,即: 垃圾回收此对象之前,总会先调用这个对象的finalize()方法</p>
</li>
<li><p>finalize()方法允许在子类中被重写.用于在对象被回收时进行资源释放,通常这个方法中进行一些资源释放和清理的工作,比如关闭文件,套接字和数据库连接</p>
</li>
<li><p>应该交给垃圾回收机制调用,理由包括下面三点:永远不要主动调用某个对象的finalize()方法</p>
<ul>
<li>在finalize() 时可能会导致对象复活</li>
<li>finalize()方法的执行时间是没有保障的,它完全由GC线程决定,极端情况下若不发生GC,则finalize()方法将没有执行机会</li>
<li>一个糟糕的finalize()会严重影响GC的性能</li>
</ul>
</li>
<li><p>从功能上说,finalize()方法与C++中的析构函数比较相似,但是java采用的是基于垃圾回收器的自动内存管理机制,所以finalize()方法在本质上不同于c++中的析构函数</p>
</li>
<li><p>由于finalize()方法的存在,虚拟机中的对象一般都处于三种可能的状态</p>
</li>
<li><p>如果从所有的根节点都无法访问到某个对象,说明对象已经不再使用了.一般来说,此对象需要被回收.但事实上,也并非是非死不可的.这时候它们暂时处于缓刑阶段.一个无法触及的对象有可能在某一个条件下”复活”自己,如果这样,那么对它的回收就是不合理的,为此,定义虚拟机中的对象可能的三种状态</p>
<ul>
<li>可触及的: 从根节点开始,可以到达这个对象</li>
<li>可复活的: 对象的所有引用都被释放,但是对象有可能在finalize()中复活</li>
<li>不可触及的: 对象的finalize()被调用,并且没有复活,那么就会进入不可触及状态. 不可触及的对象不可能被复活,因为finalize()只会被调用一次</li>
</ul>
<p>以上三种状态中,是由于finalize()方法的存在,进行的区分.只有在对象不可触及时才可以被回收</p>
</li>
</ul>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/xyingtao/blogimage/raw/master/image-20200623124755608.png" alt="image-20200623124755608"></p>
<h2 id="代码演示可复活的对象"><a href="#代码演示可复活的对象" class="headerlink" title="代码演示可复活的对象"></a>代码演示可复活的对象</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试Object类中finalize()方法，即对象的finalization机制。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shkstart</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020 下午 2:57</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CanReliveObj</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> CanReliveObj obj;<span class="comment">//类变量，属于 GC Root</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//此方法只能被调用一次</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="built_in">super</span>.finalize();</span><br><span class="line">        System.out.println(<span class="string">&quot;调用当前类重写的finalize()方法&quot;</span>);</span><br><span class="line">        obj = <span class="built_in">this</span>;<span class="comment">//当前待回收的对象在finalize()方法中与引用链上的一个对象obj建立了联系</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            obj = <span class="keyword">new</span> <span class="title class_">CanReliveObj</span>();</span><br><span class="line">            <span class="comment">// 对象第一次成功拯救自己</span></span><br><span class="line">            obj = <span class="literal">null</span>;</span><br><span class="line">            System.gc();<span class="comment">//调用垃圾回收器</span></span><br><span class="line">            System.out.println(<span class="string">&quot;第1次 gc&quot;</span>);</span><br><span class="line">            <span class="comment">// 因为Finalizer线程优先级很低，暂停2秒，以等待它</span></span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            <span class="keyword">if</span> (obj == <span class="literal">null</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;obj is dead&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;obj is still alive&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;第2次 gc&quot;</span>);</span><br><span class="line">            <span class="comment">// 下面这段代码与上面的完全相同，但是这次自救却失败了</span></span><br><span class="line">            obj = <span class="literal">null</span>;</span><br><span class="line">            System.gc();</span><br><span class="line">            <span class="comment">// 因为Finalizer线程优先级很低，暂停2秒，以等待它</span></span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            <span class="keyword">if</span> (obj == <span class="literal">null</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;obj is dead&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;obj is still alive&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="MAT和JProfiler进行GCroots-溯源"><a href="#MAT和JProfiler进行GCroots-溯源" class="headerlink" title="MAT和JProfiler进行GCroots 溯源"></a>MAT和JProfiler进行GCroots 溯源</h2><p>MAT是Memory Analyzer的简称,它是一款功能强大的Java堆内存分析器.用于查找内存泄漏以及查看内存消耗的情况.它基于Eclipse开发 的 是一款免费的性能分析工具</p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/xyingtao/blogimage/raw/master/image-20200623130401814.png" alt="image-20200623130401814"></p>
<h2 id="使用Jprofiler分析OOM"><a href="#使用Jprofiler分析OOM" class="headerlink" title="使用Jprofiler分析OOM"></a>使用Jprofiler分析OOM</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * -Xms8m -Xmx8m -XX:+HeapDumpOnOutOfMemoryError</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shkstart  shkstart@126.com</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020  15:29</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HeapOOM</span> &#123;</span><br><span class="line">    <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1</span> * <span class="number">1024</span> * <span class="number">1024</span>];<span class="comment">//1MB</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;HeapOOM&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">                list.add(<span class="keyword">new</span> <span class="title class_">HeapOOM</span>());</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Throwable e)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;count = &quot;</span> + count);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="清除阶段"><a href="#清除阶段" class="headerlink" title="清除阶段"></a>清除阶段</h1><p>当成功分出内存中存活对象和死亡对象后 GC接下来的任务就是执行垃圾回收 释放掉无用对象所占有的内存空间 以便有足够的可用内存空间为新对象分配内存</p>
<p>目前在JVM中比较常见的三种垃圾收集算法是</p>
<p><code>标记-清除算法(Mark-Sweep)</code></p>
<p><code>复制算法(Copying)</code> </p>
<p><code>标记压缩算法(Mark-Compact)</code></p>
<h2 id="标记清除算法"><a href="#标记清除算法" class="headerlink" title="标记清除算法"></a>标记清除算法</h2><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/xyingtao/blogimage/raw/master/image-20200624121038516.png" alt="image-20200624121038516"></p>
<p>标记的是: 被引用的对象 可达对象 非垃圾对象</p>
<p>标记在 Header对象头</p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/xyingtao/blogimage/raw/master/image-20200624121357435.png" alt="image-20200624121357435"></p>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>效率不算高</li>
<li>在进行GC的时候 需要停止整个应用程序 导致用户体验差</li>
<li>这种方式清理出来的空闲内存是不连续的 产生内存碎片 需要维护一个空闲列表</li>
</ul>
<p><strong>注意: 何为清除?</strong></p>
<ul>
<li>这里的清除并不是 真的置空 而是把需要清除的对象地址保存在空闲的地址列表里 下次有新对象需要加载时 判断垃圾的位置空间是否足够 如果够就存放</li>
</ul>
<h2 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h2><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/xyingtao/blogimage/raw/master/image-20200624122119572.png" alt="image-20200624122119572"></p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/xyingtao/blogimage/raw/master/image-20200624122218514.png" alt="image-20200624122218514"></p>
<p>新生代 s1 s0 使用的也是复制算法</p>
<p>地址改变</p>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li>没有标记和清除过程 实现简单 运行高效</li>
<li>复制过去以后保证空间的连续性 不会出现碎片问题</li>
</ul>
<h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>此算法的缺点也是很明显 需要两倍的内存空间 </li>
<li>对于G1这种分拆成为大量region的GC 复制不是移动 而意味着GC需要维护region之间对象引用关系 不管是内存占用或者时间开销也不小</li>
</ul>
<p>特别的 如果系统中垃圾很多 复制算法不理想 </p>
<p>需要复制的存活对象数量通常并不会太大,或者说非常低才可以</p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/xyingtao/blogimage/raw/master/image-20200624123510999.png" alt="image-20200624123510999"></p>
<h2 id="标记-压缩算法"><a href="#标记-压缩算法" class="headerlink" title="标记 压缩算法"></a>标记 压缩算法</h2><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/xyingtao/blogimage/raw/master/image-20200624123708813.png" alt="image-20200624123708813"></p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/xyingtao/blogimage/raw/master/image-20200624123934818.png" alt="image-20200624123934818"></p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/xyingtao/blogimage/raw/master/image-20200624124112997.png" alt="image-20200624124112997"></p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/xyingtao/blogimage/raw/master/image-20200624124737770.png" alt="image-20200624124318995"></p>
<h1 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h1><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/xyingtao/blogimage/raw/master/image-20200624125452539.png" alt="image-20200624125452539"></p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/xyingtao/blogimage/raw/master/image-20200624125605193.png" alt="image-20200624125605193"></p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/xyingtao/blogimage/raw/master/image-20200624130007194.png" alt="image-20200624130007194"></p>
<h2 id="增量收集算法-分代算法"><a href="#增量收集算法-分代算法" class="headerlink" title="增量收集算法 分代算法"></a>增量收集算法 分代算法</h2><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/xyingtao/blogimage/raw/master/image-20200624130240985.png" alt="image-20200624130240985"></p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/xyingtao/blogimage/raw/master/image-20200624132303603.png" alt="image-20200624132303603"></p>
<h2 id="分区算法"><a href="#分区算法" class="headerlink" title="分区算法"></a>分区算法</h2><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/xyingtao/blogimage/raw/master/image-20200624132606614.png" alt="image-20200624132606614"></p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20200624132849024.png" alt="image-20200624132849024"></p>
<h1 id="垃圾回收相关概念"><a href="#垃圾回收相关概念" class="headerlink" title="垃圾回收相关概念"></a>垃圾回收相关概念</h1><h2 id="System-gc-理解"><a href="#System-gc-理解" class="headerlink" title="System.gc()理解"></a>System.gc()理解</h2><ul>
<li><p>在默认情况下 通过System.gc()或者Runtime.getRuntime().gc()的调用 会显式触发FullGC同时对老年代和新生代进行回收 尝试释放被丢弃对象占用的内存</p>
</li>
<li><p>然而System.gc()调用附带一个免责声明 无法保证垃圾收集器的调用</p>
</li>
<li><p>JVM可以通过System.gc()调用来决定JVM的GC行为 二一般情况下 垃圾回收应该是自动进行的 无须手动触发 否则就太过于麻烦了 在一些特殊情况下 例如我们正在编写一个性能基准 我们可以在运行期间调用System.gc()</p>
</li>
</ul>
<h2 id="内存溢出和泄漏"><a href="#内存溢出和泄漏" class="headerlink" title="内存溢出和泄漏"></a>内存溢出和泄漏</h2><ul>
<li>内存溢出对于内存泄漏来说,尽管更容易被理解,但是同样的,内存溢出也是引发程序崩溃的罪魁祸首之一</li>
<li>由于GC一直在发展,所以一般情况下,除非应用程序占用的内存增长速度非常快,造成垃圾回收已经跟不上内存消耗的速度,否则不太容易出现OOM的情况</li>
<li>大多数情况下,GC会进行各种年龄段的垃圾回收,实在不行了就放大招,来一次独占式的FullGC操作,这时候会回收大量的内存,供应用程序继续使用</li>
<li>javadoc中对OOM的解释是,没有空闲内存,并且垃圾收集器也无法提供更多内存</li>
</ul>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/xyingtao/blogimage/raw/master/image-20200624142836375.png" alt="image-20200624142836375"></p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/xyingtao/blogimage/raw/master/image-20200624143118774.png" alt="image-20200624143118774"></p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/xyingtao/blogimage/raw/master/image-20200624143308097.png" alt="image-20200624143308097"> </p>
<h1 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h1><h2 id="GC分类和性能"><a href="#GC分类和性能" class="headerlink" title="GC分类和性能"></a>GC分类和性能</h2><h3 id="垃圾回收器概论"><a href="#垃圾回收器概论" class="headerlink" title="垃圾回收器概论"></a>垃圾回收器概论</h3><ul>
<li>垃圾收集器没有在规范中有过多的规定,可以由不同的厂商,不同版本的JVM来实现</li>
<li>由于JDK的版本处于高速迭代过程中,因此Java发展至今已经衍生了众多的GC版本</li>
<li>从不同的角度分析垃圾收集器,可以将GC分为不同的类型</li>
</ul>
<h3 id="垃圾回收器分类"><a href="#垃圾回收器分类" class="headerlink" title="垃圾回收器分类"></a>垃圾回收器分类</h3><ul>
<li>按线程数分,可以分为<code>串行垃圾回收器</code>和<code>并行垃圾回收器</code></li>
</ul>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/xyingtao/blogimage/raw/master/image-20210328205230978.png" alt="image-20210328205230978"></p>
<ul>
<li><p>串行回收指的是在同一时间段内只允许有一个CPU用于执行垃圾回收操作,此时工作线程被暂停,直至垃圾收集工作结束</p>
<ul>
<li><p>在诸如单CPU处理器或者较小的应用内存等硬件平台不是特别优越的场合,串行回收期的性能表现可以超过并行回收器和并发回收器.</p>
<p>所以串行回收被默认应用在<strong>客户端的Client模式下的JVM</strong>中</p>
</li>
<li><p>在并发能力较强的CPU上,并行回收器产生的停顿时间要短于串行回收器</p>
</li>
</ul>
</li>
<li><p>和串行回收相反,并行收集可以运用多个CPU同时执行垃圾回收,因此提升了应用的吞吐量,不过并行回收仍然和串行回收一样,采用独占式,使用”Stop-the-world”机制</p>
</li>
<li><p>按照工作模式分,可以分为并发式垃圾回收器和独占式垃圾回收器</p>
<ul>
<li>并发式垃圾回收器与应用线程交替工作,尽可能减少应用程序的停顿时间</li>
<li>独占式垃圾回收器(Stop the world)一旦运行,就停止应用程序中所有的用户线程,直到垃圾回收过程完全结束</li>
</ul>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/xyingtao/blogimage/raw/master/image-20210328210002927.png" alt="image-20210328210002927"></p>
</li>
<li><p>按碎片处理方式分,可分为压缩式垃圾回收器和非压缩式垃圾回收器</p>
<ul>
<li>压缩式垃圾回收器会在回收完成之后,对存活对象进行压缩整理,清除回收后的碎片</li>
<li>非压缩式的垃圾回收器不进行这步操作</li>
</ul>
</li>
<li><p>按工作的内存区间分,又可分为年轻代垃圾回收器和老年代垃圾回收器</p>
</li>
</ul>
<h3 id="评估GC的性能指标"><a href="#评估GC的性能指标" class="headerlink" title="评估GC的性能指标"></a>评估GC的性能指标</h3><ul>
<li><code>吞吐量</code>: 运行用户代码的时间占总运行时间的比例<ul>
<li>总运行时间: 程序运行时间+内存回收的时间</li>
</ul>
</li>
<li><code>垃圾收集开销</code>: 吞吐量的补数,垃圾收集所用的时间与总运行时间的比例</li>
<li><code>暂停时间</code>: 执行垃圾收集时,程序的工作线程被暂停的时间</li>
<li><code>收集频率</code>: 相对于应用程序的执行,收集操作发生的频率</li>
<li><code>内存占用</code>: Java堆区所占的内存大小</li>
<li><code>快速</code>: 一个对象从诞生到被回收所经历的时间</li>
</ul>
<p>吞吐量,暂停时间,内存占用 三者共同构成一个不可能三角</p>
<ul>
<li><p>三者总体表现会随着技术进步而越来越好.一款优秀的收集器通常最多同时满足其中的两项</p>
</li>
<li><p>这三项里,暂停时间的重要性日益凸显. 因为随着硬件发展,内存占用多些越来越能容忍,硬件性能的提升也有助于降低垃圾收集器运行时对应用程序的影响,即提高吞吐量.而内存的扩大对延迟反而带来负面的效果</p>
</li>
<li><p>简单来说,主要抓住亮点: 吞吐量 暂停时间</p>
</li>
</ul>
<h3 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h3><p>吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值,即吞吐量&#x3D;运行用户代码时间&#x2F;(运行用户代码时间+垃圾收集时间)</p>
<p>比如:虚拟机总共运行了100分钟,其中垃圾收集花掉1分钟,那吞吐量就是99%</p>
<p>这种情况下应用程序能容忍较高的暂停时间,因此,高吞吐量的应用程序有更长的时间基准,快速响应是不必考虑的</p>
<p>吞吐量优先,以为着在单位时间内,STW的时间最短:0.2+0.2&#x3D;0.4</p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/xyingtao/blogimage/raw/master/image-20210328211732123.png" alt="image-20210328211732123"></p>
<h3 id="暂停时间"><a href="#暂停时间" class="headerlink" title="暂停时间"></a>暂停时间</h3><p>暂停时间是指一个时间段内的应用程序线程暂停,让GC线程执行的状态</p>
<p>例如,GC期间100毫秒的暂停时间意味着这100毫秒期间内没有应用程序线程是活动的</p>
<p>暂停时间优先,意味着尽可能让单次STW的时间最短:0.1+0.1+0.1+0.1+0.1&#x3D;0.5</p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/xyingtao/blogimage/raw/master/image-20210328212212936.png" alt="image-20210328212212936"></p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/xyingtao/blogimage/raw/master/image-20210328212510665.png" alt="image-20210328212510665"></p>
<p>再设计或使用GC算法时,我们必须确定我们的目标:一个GC算法只可能针对两个目标之一,或尝试找到一个二者的折中</p>
<p>现在标准: 在最大吞吐量优先的情况下,降低停顿时间</p>
<h2 id="不同垃圾回收器概述"><a href="#不同垃圾回收器概述" class="headerlink" title="不同垃圾回收器概述"></a>不同垃圾回收器概述</h2><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/xyingtao/blogimage/raw/master/image-20210328213137206.png" alt="image-20210328213137206"></p>
<h3 id="7款经典的垃圾收集器"><a href="#7款经典的垃圾收集器" class="headerlink" title="7款经典的垃圾收集器"></a>7款经典的垃圾收集器</h3><ul>
<li>串行回收器: Serial,Serial Old </li>
<li>并行回收器: ParNew, Parallel Scavenge, Parallel Old</li>
<li>并发回收器: CMS, G1</li>
</ul>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/xyingtao/blogimage/raw/master/image-20210328224316971.png" alt="image-20210328224316971"></p>
<h3 id="垃圾收集器的组合关系"><a href="#垃圾收集器的组合关系" class="headerlink" title="垃圾收集器的组合关系"></a>垃圾收集器的组合关系</h3><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/xyingtao/blogimage/raw/master/image-20210328213356107.png" alt="image-20210328213356107"></p>
<h3 id="查看默认的垃圾收集器"><a href="#查看默认的垃圾收集器" class="headerlink" title="查看默认的垃圾收集器"></a>查看默认的垃圾收集器</h3><p>-XX: +PrintCommandLineFlags: 查看命令行相关参数(包含使用的垃圾收集器)</p>
<p>使用命令行指令: jinfo -flag 相关垃圾回收器参数 进程ID</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">樱桃先生</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/posts/72f47432/">http://example.com/posts/72f47432/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://example.com" target="_blank">樱桃先生</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/JVM/">JVM</a><a class="post-meta__tags" href="/tags/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/">垃圾回收</a></div><div class="post-share"><div class="social-share" data-image="https://ytblogpic.oss-cn-guangzhou.aliyuncs.com/blog-common.png" data-sites="wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赞助</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://s2.loli.net/2022/08/21/Ay5sujrkH1nLTwW.jpg" target="_blank"><img class="post-qr-code-img" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2022/08/21/Ay5sujrkH1nLTwW.jpg" alt="Wechat"/></a><div class="post-qr-code-desc">Wechat</div></li></ul></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/posts/d5253164/" title="重排序"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://ytblogpic.oss-cn-guangzhou.aliyuncs.com/blog-common.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">重排序</div></div><div class="info-2"><div class="info-item-1">重排序重排序是指编译器和处理器为了优化程序性能而对指令序列进行重新排序的一种手段. 数据依赖性如果两个操作访问同一个变量,且这两个操作中有一个为写操作,此时这两个操作之间就存在数据依赖性.数据依赖分为下列3种类型    名称 代码示例 说明    写后读 a&#x3D;1;b&#x3D;a; 写一个变量之后,再读这个位置   写后写 a&#x3D;1;a&#x3D;2; 写一个变量之后,再写这个变量   读后写 a&#x3D;b;b&#x3D;1; 读一个变量之后,再写这个变量   上面 三种情况,只要重排序两个操作的执行顺序,程序的执行结果就会被改变. 编译器和处理器可能会对操作做重排序.编译器和处理器的重排序会尊重数据依赖性,编译器和处理器不会改变存在数据依赖关系的两个操作的执行顺序. 这里所说的数据依赖性仅针对单个处理器中执行的指令序列和单个线程中执行的操作,不同处理器之间和不同线程之间的数据依赖性不被编译器和处理器考虑 as-if-serial语义as-if-serial语义的意思是:不管怎么重排序(编译器和处理器为了提高并行度).(单线程)的执行结果不能被改变.编译器,...</div></div></div></a><a class="pagination-related" href="/posts/223a19f9/" title="对象实例化和内存布局"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://ytblogpic.oss-cn-guangzhou.aliyuncs.com/blog-common.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">对象实例化和内存布局</div></div><div class="info-2"><div class="info-item-1">对象实例化 创建对象的六步骤 虚拟机遇到一条new指令 首先去检查这个指令的参数能否在Metaspace的常量池中定位到一个类的符号引用 并且检查这个符号引用代表的类是否已经被加载 解析和初始化 (即判断类元信息是否存在)  如果没有 那么在双亲委派模式下 使用当前类加载器以ClassLoader+包名+类名为key 查找对应的class文件 如果没有找到 则抛出 ClassNotFoundException异常  如果找到 则进行类加载 并生成对应的class类对象  为对象分配内存(首先计算对象占用空间大小 接着在堆中划分一块内存给新对象 如果实例成员变量是引用变量 仅分配引用变量空间即可 即四个字节大小)  如果内存规整 指针碰撞 意思是 所有用过的内存在一边 空闲的内存在另一边 中间放着一个指针作为分界点的指示器  分配内存就仅仅是把指针往空闲那边挪动一段与对象大小相等的距离.如果垃圾收集器选择的是 Serial ParNew这种基于压缩算法的 虚拟机采用这种分配方式 一般使用带有compat(整理)过程的收集器时,使用指针碰撞  如果内存不规整 已使用的内存和未使用的内...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/posts/a4e160b9/" title="JVM类的加载"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://ytblogpic.oss-cn-guangzhou.aliyuncs.com/blog-common.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2020-09-17</div><div class="info-item-2">JVM类的加载</div></div><div class="info-2"><div class="info-item-1">JVM类的加载器和加载过程 之前JVM的那篇笔记实在太长了 不方便 查阅 故在复习时把每个章节拆出来独立成文  类加载器子系统作用  类加载器子系统 负责从文件系统或者网络中加载class文件 class文件在文件开头有特定的文件标识 ClassLoader只负责class文件的加载 ,至于他是否可以运行,则由Execution Engine 执行引擎决定 加载的类信息 存放于一块称为方法区的内存空间. 方法区还会存放运行时常量池信息 可能还包括字符串 字面量和数字常量 (这部分常量信息是class文件中的常量池)  类加载器  class file存在于本地硬盘 可以理解为设计师画在纸上的模板 而最终这个模板在执行的时候是要加载到JVM中来 根据这个文件 实例化出n个一模一样的实例 class file加载到JVM中 称为DNA元数据模板 放在方法区 在class文件 – &gt;jvm –&gt;元数据模板 过程需要一个运输工具 (类装载器) 左边为堆空间  类的加载过程  加载 通过一个类的全限定名获取定义此类的二进制字节流  将这个字节流所代表的静态存储结构转化为方法区的...</div></div></div></a><a class="pagination-related" href="/posts/cb6f9b2d/" title="JVM"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://ytblogpic.oss-cn-guangzhou.aliyuncs.com/blog-common.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2020-09-17</div><div class="info-item-2">JVM</div></div><div class="info-2"><div class="info-item-1">JVM字节码准确的说 任何能在JVM平台上执行的字节码格式都是一样的 所以应该统称为jvm字节码 虚拟机所谓虚拟机 就是一台虚拟的计算机 是一款软件 用来执行一系列虚拟机计算机指令 大体上可分为 系统虚拟机  和 程序虚拟机 Java虚拟机是一台执行 java字节码的虚拟计算机  java技术的核心就是java虚拟机  HotSpot JRocket J9 三大虚拟机 Java虚拟机就是二进制字节码的运行环境 特点:  一次编译 到处运行 自动内存管理 自动垃圾回收机制  jvm是运行在操作系统之上的 它与硬件没有直接的交互  JVM的整体结构 HotSpot VM是目前市面上高性能虚拟机的代表作之一 它采用 解释器和即时编译器 并存的架构  方法区 和 堆  多线程共享 栈 本地方法栈 程序计数器 每个线程独享一份 执行引擎 (3部分) : 解释器(JIT编译器 ) 即时编译器 垃圾回收器 负责 将高级语言 翻译成 机器语言   第一次编译成字节码文件 第二次在JIT编译成机器指令  JVM的架构模型Java编译器输入的指令流基本上是一种基于栈的指令集架构 另外一种指令集架构是...</div></div></div></a><a class="pagination-related" href="/posts/223a19f9/" title="对象实例化和内存布局"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://ytblogpic.oss-cn-guangzhou.aliyuncs.com/blog-common.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2021-03-28</div><div class="info-item-2">对象实例化和内存布局</div></div><div class="info-2"><div class="info-item-1">对象实例化 创建对象的六步骤 虚拟机遇到一条new指令 首先去检查这个指令的参数能否在Metaspace的常量池中定位到一个类的符号引用 并且检查这个符号引用代表的类是否已经被加载 解析和初始化 (即判断类元信息是否存在)  如果没有 那么在双亲委派模式下 使用当前类加载器以ClassLoader+包名+类名为key 查找对应的class文件 如果没有找到 则抛出 ClassNotFoundException异常  如果找到 则进行类加载 并生成对应的class类对象  为对象分配内存(首先计算对象占用空间大小 接着在堆中划分一块内存给新对象 如果实例成员变量是引用变量 仅分配引用变量空间即可 即四个字节大小)  如果内存规整 指针碰撞 意思是 所有用过的内存在一边 空闲的内存在另一边 中间放着一个指针作为分界点的指示器  分配内存就仅仅是把指针往空闲那边挪动一段与对象大小相等的距离.如果垃圾收集器选择的是 Serial ParNew这种基于压缩算法的 虚拟机采用这种分配方式 一般使用带有compat(整理)过程的收集器时,使用指针碰撞  如果内存不规整 已使用的内存和未使用的内...</div></div></div></a><a class="pagination-related" href="/posts/d1f47d1d/" title="运行时数据区及线程"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://ytblogpic.oss-cn-guangzhou.aliyuncs.com/blog-common.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2021-03-06</div><div class="info-item-2">运行时数据区及线程</div></div><div class="info-2"><div class="info-item-1">运行时数据区概述以及线程运行时数据区内部结构 内存是非常重要的系统资源 是硬盘和cpu的中间仓库和桥梁, JVM内存布局 规定了java在运行过程中内存申请 分配 管理的策略,保证了JVM的高效稳定运行. 不同的JVM对于内存划分和管理机制存在部分差异 结合JVM虚拟机规范,探讨经典的JVM内存布局   Java虚拟机定义了若干种程序运行期间会使用到的运行时数据区,其中有一些会随着虚拟机启动而创建,随着虚拟机退出而销毁.另外一些则是与线程一一对应的,这些与线程对应的数据区域会随着线程开始和结束而创建和销毁.  每个线程: 独立包括程序计数器  栈  本地栈  线程间共享: 堆 堆外内存(永久代或元空间, 代码缓存)    线程 线程是一个应用程序里的运行单元 JVM允许一个应用有多个线程并行执行 在HotSpot里 每个线程都与操作系统的本地线程直接映射 当一个java线程准备好执行以后 此时一个操作系统的本地线程也同时创建 java线程执行终止后 本地线程也会回收   操作系统负责所有线程的安排调度到任何一个可用的CPU上 一旦本地线程初始化成功 他就会调用java线程中的ru...</div></div></div></a><a class="pagination-related" href="/posts/d7c99bec/" title="执行引擎"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://ytblogpic.oss-cn-guangzhou.aliyuncs.com/blog-common.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2020-09-17</div><div class="info-item-2">执行引擎</div></div><div class="info-2"><div class="info-item-1">执行引擎 执行引擎是Java虚拟机核心的组成部分之一  “虚拟机”是一个相对于”物理机”的概念,这两种机器都有代码执行能力,其区别是物理机的执行引擎是直接建立在处理器,缓存,指令集和操作系统层面上的,而虚拟机的执行引擎则是由软件自行实现的,因此可以不受物理条件制约地定制指令集与执行引擎的结构体系,能够执行那些不被硬件直接支持的指令集格式  JVM的主要任务是负责装载字节码到内部,但字节码并不能够直接运行在操作系统之上,因为字节码指令并非等价于本地机器指令,它内部包含的仅仅是一些能够被JVM所识别的字节码指令,符号表,以及其他辅助信息  那么,如果想要让一个Java程序运行起来,执行引擎的任务就是将字节码指令解释&#x2F;编译为对应平台上的本地机器指令才可以.简单来说,JVM的执行引擎充当了将高级语言翻译为机器语言的译者    java代码编译和 执行的过程  问题:什么是解释器,什么是JIT编译器?解释器:当Java虚拟机启动的时候会根据预定义的规范对字节码采用逐行解释的方式执行,将每条字节码文件中的内容”翻译”为对应平台的本地机器指令执行 JIT编译器: 就是虚拟机将源代码直...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2022/08/20/hk9Zvq4YRsIcnrw.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">樱桃先生</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">78</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">65</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">21</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://ytblogpic.oss-cn-guangzhou.aliyuncs.com/typoraWechat.jpeg"><i class="fab fa-weixin"></i><span>加为好友</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎光临樱桃先生的博客🍒～</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="toc-number">1.</span> <span class="toc-text">垃圾回收</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%9E%83%E5%9C%BE"><span class="toc-number">1.1.</span> <span class="toc-text">什么是垃圾</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81GC"><span class="toc-number">1.2.</span> <span class="toc-text">为什么需要GC?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%A9%E6%9C%9F%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="toc-number">1.3.</span> <span class="toc-text">早期垃圾回收</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6"><span class="toc-number">1.4.</span> <span class="toc-text">Java垃圾回收机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#GC%E7%9A%84%E4%BD%9C%E7%94%A8%E5%8C%BA%E5%9F%9F-%E6%96%B9%E6%B3%95%E5%8C%BA-%E5%A0%86"><span class="toc-number">1.5.</span> <span class="toc-text">GC的作用区域 方法区 堆</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95"><span class="toc-number">2.</span> <span class="toc-text">垃圾回收相关算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E6%A0%87%E8%AE%B0%E9%98%B6%E6%AE%B5%E7%9A%84%E7%AE%97%E6%B3%95%E5%80%BC%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E7%AE%97%E6%B3%95"><span class="toc-number">2.1.</span> <span class="toc-text">垃圾标记阶段的算法值引用计数算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F%E4%B8%80-%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E7%AE%97%E6%B3%95-Java%E4%B8%8D%E7%94%A8"><span class="toc-number">2.2.</span> <span class="toc-text">方式一:引用计数算法(Java不用)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F%E4%BA%8C-%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E7%AE%97%E6%B3%95-%E6%A0%B9%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95-%E8%BF%BD%E8%B8%AA%E6%80%A7%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86"><span class="toc-number">2.3.</span> <span class="toc-text">方式二:可达性分析算法(根搜索算法 追踪性垃圾收集)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF"><span class="toc-number">2.3.1.</span> <span class="toc-text">基本思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GC-Roots-%E5%8C%85%E6%8B%AC%E4%BB%A5%E4%B8%8B%E5%87%A0%E7%B1%BB%E5%85%83%E7%B4%A0"><span class="toc-number">2.3.2.</span> <span class="toc-text">GC Roots 包括以下几类元素</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84finalization"><span class="toc-number">2.4.</span> <span class="toc-text">对象的finalization</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E6%BC%94%E7%A4%BA%E5%8F%AF%E5%A4%8D%E6%B4%BB%E7%9A%84%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.5.</span> <span class="toc-text">代码演示可复活的对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MAT%E5%92%8CJProfiler%E8%BF%9B%E8%A1%8CGCroots-%E6%BA%AF%E6%BA%90"><span class="toc-number">2.6.</span> <span class="toc-text">MAT和JProfiler进行GCroots 溯源</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8Jprofiler%E5%88%86%E6%9E%90OOM"><span class="toc-number">2.7.</span> <span class="toc-text">使用Jprofiler分析OOM</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B8%85%E9%99%A4%E9%98%B6%E6%AE%B5"><span class="toc-number">3.</span> <span class="toc-text">清除阶段</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95"><span class="toc-number">3.1.</span> <span class="toc-text">标记清除算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9"><span class="toc-number">3.1.1.</span> <span class="toc-text">缺点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95"><span class="toc-number">3.2.</span> <span class="toc-text">复制算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E7%82%B9"><span class="toc-number">3.2.1.</span> <span class="toc-text">优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9-1"><span class="toc-number">3.2.2.</span> <span class="toc-text">缺点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%87%E8%AE%B0-%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95"><span class="toc-number">3.3.</span> <span class="toc-text">标记 压缩算法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%86%E4%BB%A3%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95"><span class="toc-number">4.</span> <span class="toc-text">分代收集算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A2%9E%E9%87%8F%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95-%E5%88%86%E4%BB%A3%E7%AE%97%E6%B3%95"><span class="toc-number">4.1.</span> <span class="toc-text">增量收集算法 分代算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%8C%BA%E7%AE%97%E6%B3%95"><span class="toc-number">4.2.</span> <span class="toc-text">分区算法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5"><span class="toc-number">5.</span> <span class="toc-text">垃圾回收相关概念</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#System-gc-%E7%90%86%E8%A7%A3"><span class="toc-number">5.1.</span> <span class="toc-text">System.gc()理解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%92%8C%E6%B3%84%E6%BC%8F"><span class="toc-number">5.2.</span> <span class="toc-text">内存溢出和泄漏</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8"><span class="toc-number">6.</span> <span class="toc-text">垃圾回收器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#GC%E5%88%86%E7%B1%BB%E5%92%8C%E6%80%A7%E8%83%BD"><span class="toc-number">6.1.</span> <span class="toc-text">GC分类和性能</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E6%A6%82%E8%AE%BA"><span class="toc-number">6.1.1.</span> <span class="toc-text">垃圾回收器概论</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E5%88%86%E7%B1%BB"><span class="toc-number">6.1.2.</span> <span class="toc-text">垃圾回收器分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%84%E4%BC%B0GC%E7%9A%84%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87"><span class="toc-number">6.1.3.</span> <span class="toc-text">评估GC的性能指标</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%9E%E5%90%90%E9%87%8F"><span class="toc-number">6.1.4.</span> <span class="toc-text">吞吐量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9A%82%E5%81%9C%E6%97%B6%E9%97%B4"><span class="toc-number">6.1.5.</span> <span class="toc-text">暂停时间</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8D%E5%90%8C%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E6%A6%82%E8%BF%B0"><span class="toc-number">6.2.</span> <span class="toc-text">不同垃圾回收器概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7%E6%AC%BE%E7%BB%8F%E5%85%B8%E7%9A%84%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">6.2.1.</span> <span class="toc-text">7款经典的垃圾收集器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E7%9A%84%E7%BB%84%E5%90%88%E5%85%B3%E7%B3%BB"><span class="toc-number">6.2.2.</span> <span class="toc-text">垃圾收集器的组合关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E9%BB%98%E8%AE%A4%E7%9A%84%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">6.2.3.</span> <span class="toc-text">查看默认的垃圾收集器</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/4995/" title="顺德好友小聚"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://ytblogpic.oss-cn-guangzhou.aliyuncs.com/blog-common.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="顺德好友小聚"/></a><div class="content"><a class="title" href="/posts/4995/" title="顺德好友小聚">顺德好友小聚</a><time datetime="2023-05-07T13:56:00.000Z" title="发表于 2023-05-07 21:56:00">2023-05-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/51438/" title="旅游归来的周末"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://ytblogpic.oss-cn-guangzhou.aliyuncs.com/blog-common.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="旅游归来的周末"/></a><div class="content"><a class="title" href="/posts/51438/" title="旅游归来的周末">旅游归来的周末</a><time datetime="2023-05-06T05:56:00.000Z" title="发表于 2023-05-06 13:56:00">2023-05-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/34851/" title="与好友的广西之旅"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://ytblogpic.oss-cn-guangzhou.aliyuncs.com/blog-common.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="与好友的广西之旅"/></a><div class="content"><a class="title" href="/posts/34851/" title="与好友的广西之旅">与好友的广西之旅</a><time datetime="2023-05-02T04:30:00.000Z" title="发表于 2023-05-02 12:30:00">2023-05-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/53653/" title="项目管理笔记"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://ytblogpic.oss-cn-guangzhou.aliyuncs.com/typora%E6%88%AA%E5%B1%8F2022-08-27%2000.25.25.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="项目管理笔记"/></a><div class="content"><a class="title" href="/posts/53653/" title="项目管理笔记">项目管理笔记</a><time datetime="2022-08-28T04:30:00.000Z" title="发表于 2022-08-28 12:30:00">2022-08-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/53652/" title="项目管理笔记"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://ytblogpic.oss-cn-guangzhou.aliyuncs.com/blog-common.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="项目管理笔记"/></a><div class="content"><a class="title" href="/posts/53652/" title="项目管理笔记">项目管理笔记</a><time datetime="2022-08-28T04:30:00.000Z" title="发表于 2022-08-28 12:30:00">2022-08-28</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(https://ytblogpic.oss-cn-guangzhou.aliyuncs.com/blog-common.png);"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 By 樱桃先生</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.0</a></span></div><div class="footer_custom_text">一切都是最好的安排</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><div class="js-pjax"></div><div class="aplayer no-destroy" data-id="5225697049" data-server="netease" data-type="playlist" data-fixed="true" data-autoplay="false" data-mini="true" data-lrctype="-1"> </div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script>(() => {
  const destroyAplayer = () => {
    if (window.aplayers) {
      for (let i = 0; i < window.aplayers.length; i++) {
        if (!window.aplayers[i].options.fixed) {
          window.aplayers[i].destroy()
        }
      }
    }
  }

  const runMetingJS = () => {
    typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()
  }

  btf.addGlobalFn('pjaxSend', destroyAplayer, 'destroyAplayer')
  btf.addGlobalFn('pjaxComplete', loadMeting, 'runMetingJS')
})()</script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>(() => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => {
      try {
        fn()
      } catch (err) {
        console.debug('Pjax callback failed:', err)
      }
    })
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      const usePjax = true
      false
        ? (usePjax ? pjax.loadUrl('/404.html') : window.location.href = '/404.html')
        : window.location.href = e.request.responseURL
    }
  })
})()</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>