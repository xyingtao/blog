<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>JVM类的加载 | Hexo</title><meta name="author" content="John Doe"><meta name="copyright" content="John Doe"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="JVM类的加载器和加载过程 之前JVM的那篇笔记实在太长了 不方便 查阅 故在复习时把每个章节拆出来独立成文  类加载器子系统作用  类加载器子系统 负责从文件系统或者网络中加载class文件 class文件在文件开头有特定的文件标识 ClassLoader只负责class文件的加载 ,至于他是否可以运行,则由Execution Engine 执行引擎决定 加载的类信息 存放于一块称为方法区的内存">
<meta property="og:type" content="article">
<meta property="og:title" content="JVM类的加载">
<meta property="og:url" content="http://example.com/2020/09/17/%E6%8A%80%E6%9C%AF/JVM/JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="JVM类的加载器和加载过程 之前JVM的那篇笔记实在太长了 不方便 查阅 故在复习时把每个章节拆出来独立成文  类加载器子系统作用  类加载器子系统 负责从文件系统或者网络中加载class文件 class文件在文件开头有特定的文件标识 ClassLoader只负责class文件的加载 ,至于他是否可以运行,则由Execution Engine 执行引擎决定 加载的类信息 存放于一块称为方法区的内存">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/img/butterfly-icon.png">
<meta property="article:published_time" content="2020-09-17T11:50:00.000Z">
<meta property="article:modified_time" content="2021-03-05T17:05:00.000Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="JVM">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/butterfly-icon.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "JVM类的加载",
  "url": "http://example.com/2020/09/17/%E6%8A%80%E6%9C%AF/JVM/JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD/",
  "image": "http://example.com/img/butterfly-icon.png",
  "datePublished": "2020-09-17T11:50:00.000Z",
  "dateModified": "2021-03-05T17:05:00.000Z",
  "author": [
    {
      "@type": "Person",
      "name": "John Doe",
      "url": "http://example.com"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2020/09/17/%E6%8A%80%E6%9C%AF/JVM/JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Failed',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'JVM类的加载',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Hexo</span></a><a class="nav-page-title" href="/"><span class="site-name">JVM类的加载</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  Back to Home</span></span></a></span><div id="menus"></div></nav><div id="post-info"><h1 class="post-title">JVM类的加载</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2020-09-17T11:50:00.000Z" title="Created 2020-09-17 19:50:00">2020-09-17</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2021-03-05T17:05:00.000Z" title="Updated 2021-03-06 01:05:00">2021-03-06</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%8A%80%E6%9C%AF/JVM/">JVM</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="JVM类的加载器和加载过程"><a href="#JVM类的加载器和加载过程" class="headerlink" title="JVM类的加载器和加载过程"></a>JVM类的加载器和加载过程</h1><blockquote>
<p>之前JVM的那篇笔记实在太长了 不方便 查阅 故在复习时把每个章节拆出来独立成文</p>
</blockquote>
<h2 id="类加载器子系统作用"><a href="#类加载器子系统作用" class="headerlink" title="类加载器子系统作用"></a>类加载器子系统作用</h2><p><img src="https://gitee.com/xyingtao/blogimage/raw/master/image-20200616112003033-1592870597679.png" alt="image-20200616112003033"></p>
<ul>
<li>类加载器子系统 负责从<strong>文件系统或者网络中加载class文件</strong> class文件在<strong>文件开头</strong>有特定的文件<strong>标识</strong></li>
<li><strong>ClassLoader</strong>只负责class文件的加载 ,至于他是否可以运行,则由<strong>Execution Engine</strong> 执行引擎决定</li>
<li>加载的<strong>类信息</strong> 存放于一块称为<strong>方法区</strong>的内存空间. 方法区还会存放<strong>运行时常量池</strong>信息 可能还包括<strong>字符串 字面量和数字常量</strong> (这部分常量信息是class文件中的常量池)</li>
</ul>
<h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><p><img src="https://gitee.com/xyingtao/blogimage/raw/master/image-20200616114826425-1592870600862.png" alt="image-20200616114826425"></p>
<ol>
<li>class file存在于<strong>本地硬盘</strong> 可以理解为设计师画在纸上的模板 而最终这个模板在执行的时候是要加载到JVM中来 根据这个文件 实例化出n个一模一样的实例</li>
<li>class file加载到JVM中 称为<code>DNA元数据模板</code> 放在<strong>方法区</strong></li>
<li>在class文件 – &gt;jvm –&gt;元数据模板 过程需要一个运输工具 (<strong>类装载器</strong>)</li>
<li>左边为堆空间</li>
</ol>
<h2 id="类的加载过程"><a href="#类的加载过程" class="headerlink" title="类的加载过程"></a>类的加载过程</h2><p><img src="https://gitee.com/xyingtao/blogimage/raw/master/image-20200616125946258-1592870603549.png" alt="image-20200616125946258"></p>
<p><img src="https://gitee.com/xyingtao/blogimage/raw/master/image-20210306012032957.png" alt="image-20210306012032957"></p>
<h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><ol>
<li><p>通过一个类的<strong>全限定名</strong>获取定义此类的<strong>二进制字节流</strong></p>
</li>
<li><p>将这个字节流所代表的<code>静态存储结构</code>转化为方法区的<code>运行时数据结构</code></p>
<p>(方法区的落地实现 jdk7以前 永久代 jdk8之后 元空间)</p>
</li>
<li><p>在内存中生成一个 代表这个类的<strong>java.lang.class</strong>对象 作为<code>方法区</code>这个类的各种数据的访问入口</p>
</li>
</ol>
<h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><ol>
<li><strong>验证</strong></li>
</ol>
<p>目的在于确保class文件的字节流中包含的信息符合当前虚拟机要求 保证被加载类的正确性</p>
<p>不会危害虚拟机自身安全.</p>
<p>主要包括四种验证:文件格式验证.元数据验证,字节码验证,符号引用验证</p>
<ol start="2">
<li><strong>准备</strong>(Prepare)</li>
</ol>
<p>为<strong>类变量</strong>分配内存并且设置该<strong>类变量</strong>的默认初始值 即零值</p>
<p>这里不包含final修饰的static 因为final 在编译的时候就会分配了 准备阶段会<strong>显式初始化</strong></p>
<p>这里不会为 实例变量分配初始化 类变量会分配在方法区中,而实例变量是会随着对象一起分配到java堆中</p>
<p>static变量 称为类变量 静态变量</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private static int a= 1;//准备阶段: a=0 ----&gt; 初始化 a=1</span><br></pre></td></tr></table></figure>



<ol start="3">
<li><strong>解析</strong></li>
</ol>
<p>将常量池内的<strong>符号引用</strong>转换为<strong>直接引用</strong>的过程 (符号引用就是一组符号描述所引用的目标 直接引用就是直接指向目标的指针)</p>
<p>解析操作往往会伴随jvm在执行初始化后才执行</p>
<p>解析动作主要针对类或接口 字段 类方法 接口方法 方法类型 等</p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><ul>
<li><p>初始化阶段就是执行类构造器方法<code>&lt;clinit&gt;()</code>的过程</p>
<p>(如果没有类变量 )</p>
</li>
<li><p>此方法不需定义 是javac编译器 自动收集所有<strong>类变量的赋值</strong>动作和<strong>静态代码块</strong>中的语句合并而来</p>
</li>
<li><p>构造器方法中指令按照语句在源文件中出现的顺序执行</p>
</li>
<li><p><code>&lt;clinit&gt;()</code>不同于类的构造器</p>
</li>
<li><p>虚拟机必须保证一个类的<code>&lt;clinit&gt;()</code>方法在多线程下<strong>被同步加锁</strong></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassInitTest</span> &#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">static</span>&#123;</span><br><span class="line">       num = <span class="number">2</span>;</span><br><span class="line">       number = <span class="number">20</span>;</span><br><span class="line">       System.out.println(num);</span><br><span class="line">       <span class="comment">//System.out.println(number);//报错：非法的前向引用。在声明前 可以赋值 但是你不能去调用它</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">10</span>;  <span class="comment">//linking之prepare: number = 0 --&gt; initial: 20 --&gt; 10</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//之所以可以在后面声明 是因为在linking的时候已经初始化了</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(ClassInitTest.num);<span class="comment">//2</span></span><br><span class="line">        System.out.println(ClassInitTest.number);<span class="comment">//10</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>任何一个类 声明以后 内部至少存在一个类的构造器</p>
<p>成员变量a如果满足如下的4点，就必须在<strong>使用前</strong>必须对该成员变量进行<strong>声明</strong></p>
<ol>
<li>设定C为直接包含该成员变量的类或者接口</li>
<li>如果a出现在在C的或静态成员&#x2F;非静态成员初始化 或者 C的静态或非静态代码块中</li>
<li>如果a不是 一个赋值不等式的左值</li>
<li>通过简单名称来访问</li>
</ol>
<h2 id="类加载器的分类"><a href="#类加载器的分类" class="headerlink" title="类加载器的分类"></a>类加载器的分类</h2><ul>
<li><p>JVM支持两种类型的类加载器 分别为<code>引导类加载器(Bootstrap ClassLoader)</code>和<code>自定义类加载器(User-Defined ClassLoader)</code></p>
</li>
<li><p>从概念上来讲 自定义类加载器 一般指的是 程序开发中 由开发人员自定义的一类类加载器 但是java虚拟机规范却没有这么定义 而是将所有派生于抽象类<strong>ClassLoader的类</strong>加载器都划分为<strong>自定义类加载器</strong></p>
</li>
</ul>
<p><img src="https://gitee.com/xyingtao/blogimage/raw/master/image-20200616145924640-1592870611091.png" alt="image-20200616145924640"></p>
<p><strong>Bootstrap</strong>(c和c++ 编写) 是 一类 </p>
<p>其他是 一类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取系统类加载器</span></span><br><span class="line">    <span class="type">ClassLoader</span> <span class="variable">systemClassLoader</span> <span class="operator">=</span> ClassLoader.getSystemClassLoader();</span><br><span class="line">    System.out.println(systemClassLoader);<span class="comment">//sun.misc.Launcher$AppClassLoader@18b4aac2</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取其上层：扩展类加载器</span></span><br><span class="line">    <span class="type">ClassLoader</span> <span class="variable">extClassLoader</span> <span class="operator">=</span> systemClassLoader.getParent();</span><br><span class="line">    System.out.println(extClassLoader);<span class="comment">//sun.misc.Launcher$ExtClassLoader@1540e19d</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取其上层：获取不到引导类加载器</span></span><br><span class="line">    <span class="type">ClassLoader</span> <span class="variable">bootstrapClassLoader</span> <span class="operator">=</span> extClassLoader.getParent();</span><br><span class="line">    System.out.println(bootstrapClassLoader);<span class="comment">//null</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//对于用户自定义类来说：默认使用系统类加载器进行加载</span></span><br><span class="line">    <span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> ClassLoaderTest.class.getClassLoader();</span><br><span class="line">    System.out.println(classLoader);<span class="comment">//sun.misc.Launcher$AppClassLoader@18b4aac2</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//String类使用引导类加载器进行加载的。---&gt; Java的核心类库都是使用引导类加载器进行加载的。</span></span><br><span class="line">    <span class="type">ClassLoader</span> <span class="variable">classLoader1</span> <span class="operator">=</span> String.class.getClassLoader();</span><br><span class="line">    System.out.println(classLoader1);<span class="comment">//null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="启动类加载器"><a href="#启动类加载器" class="headerlink" title="启动类加载器"></a>启动类加载器</h3><ul>
<li>使用c&#x2F;c++实现 嵌套在JVM内部</li>
<li>它用来加载java的核心类库(JAVA_HOME&#x2F;jre&#x2F;lib&#x2F;rt.jar resources&#x2F;jar或sun.boot.class.path路径下的内容),用于提供JVM自身需要的类</li>
<li>并不继承自java.lang.classloader 没有父加载器</li>
<li>加载拓展类和应用程序类加载器, 并指定为他们的父类加载器</li>
<li>出于安全考虑 Boostrap启动类加载器 只加载包名为java javax sun开头的类</li>
</ul>
<h3 id="扩展类加载器-Extension-Classloader"><a href="#扩展类加载器-Extension-Classloader" class="headerlink" title="扩展类加载器(Extension Classloader)"></a>扩展类加载器(Extension Classloader)</h3><ul>
<li><p>java编写 由sun.misc.launcher$ExtClassLoader实现</p>
</li>
<li><p>派生于ClassLoader类</p>
</li>
<li><p>父类加载器为启动类加载器</p>
</li>
<li><p>从java.ext.dirs系统属性所指定的目录中加载类库 或从jdk的安装目录jre&#x2F;lib&#x2F;ext子目录下加载类库</p>
<p>如果用户创建的jar放在此目录下 也会自动由扩展类加载器加载</p>
</li>
</ul>
<h3 id="应用程序类加载器-系统类加载器-AppClassLoader"><a href="#应用程序类加载器-系统类加载器-AppClassLoader" class="headerlink" title="应用程序类加载器(系统类加载器 AppClassLoader)"></a>应用程序类加载器(系统类加载器 AppClassLoader)</h3><ul>
<li><p>java编写 由sun.misc.launcher$AppClassLoader实现</p>
</li>
<li><p>派生于ClassLoader类</p>
</li>
<li><p>父类加载器为扩展类加载器</p>
</li>
<li><p>它负责加载环境变量classpath或系统属性 java.class.path 指定路径下的类库</p>
</li>
<li><p>该类加载是程序中默认的类加载器 一般来说 java应用的类都是由他完成加载</p>
</li>
<li><p>通过ClassLoader#getSystemClassLoader()方法可以获取到该类加载器</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;**********启动类加载器**************&quot;</span>);</span><br><span class="line">    <span class="comment">//获取BootstrapClassLoader能够加载的api的路径</span></span><br><span class="line">    URL[] urLs = sun.misc.Launcher.getBootstrapClassPath().getURLs();</span><br><span class="line">    <span class="keyword">for</span> (URL element : urLs) &#123;</span><br><span class="line">        System.out.println(element.toExternalForm());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//从上面的路径中随意选择一个类,来看看他的类加载器是什么:引导类加载器</span></span><br><span class="line">    <span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> Provider.class.getClassLoader();</span><br><span class="line">    System.out.println(classLoader);<span class="comment">//null 引导类加载器</span></span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;***********扩展类加载器*************&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">extDirs</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;java.ext.dirs&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (String path : extDirs.split(<span class="string">&quot;;&quot;</span>)) &#123;</span><br><span class="line">        System.out.println(path);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从上面的路径中随意选择一个类,来看看他的类加载器是什么:扩展类加载器</span></span><br><span class="line">    <span class="type">ClassLoader</span> <span class="variable">classLoader1</span> <span class="operator">=</span> CurveDB.class.getClassLoader();</span><br><span class="line">    System.out.println(classLoader1);<span class="comment">//sun.misc.Launcher$ExtClassLoader@1540e19d</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">**********启动类加载器**************</span></span><br><span class="line"><span class="comment">file:/C:/Program%20Files/Java/jdk1.8.0_241/jre/lib/resources.jar</span></span><br><span class="line"><span class="comment">file:/C:/Program%20Files/Java/jdk1.8.0_241/jre/lib/rt.jar</span></span><br><span class="line"><span class="comment">file:/C:/Program%20Files/Java/jdk1.8.0_241/jre/lib/sunrsasign.jar</span></span><br><span class="line"><span class="comment">file:/C:/Program%20Files/Java/jdk1.8.0_241/jre/lib/jsse.jar</span></span><br><span class="line"><span class="comment">file:/C:/Program%20Files/Java/jdk1.8.0_241/jre/lib/jce.jar</span></span><br><span class="line"><span class="comment">file:/C:/Program%20Files/Java/jdk1.8.0_241/jre/lib/charsets.jar</span></span><br><span class="line"><span class="comment">file:/C:/Program%20Files/Java/jdk1.8.0_241/jre/lib/jfr.jar</span></span><br><span class="line"><span class="comment">file:/C:/Program%20Files/Java/jdk1.8.0_241/jre/classes</span></span><br><span class="line"><span class="comment">null</span></span><br><span class="line"><span class="comment">***********扩展类加载器*************</span></span><br><span class="line"><span class="comment">C:\Program Files\Java\jdk1.8.0_241\jre\lib\ext</span></span><br><span class="line"><span class="comment">C:\Windows\Sun\Java\lib\ext</span></span><br><span class="line"><span class="comment">sun.misc.Launcher$ExtClassLoader@12a3a380</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Process finished with exit code 0</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="用户自定义类加载器"><a href="#用户自定义类加载器" class="headerlink" title="用户自定义类加载器"></a>用户自定义类加载器</h3><p>为什么要自定义类加载器?</p>
<ul>
<li>隔离加载类</li>
<li>修改类加载的方式</li>
<li>扩展加载源</li>
<li>防止源码泄露</li>
</ul>
<h3 id="自定义类加载器实现步骤"><a href="#自定义类加载器实现步骤" class="headerlink" title="自定义类加载器实现步骤"></a>自定义类加载器实现步骤</h3><ol>
<li>继承抽象类java.lang.ClassLoader类的方式 实现自己的类加载器</li>
<li>JDK1.2之前 在自定义类加载器是 总会去继承classloader并重写loadclass()从而实现 自定义 但是1.2之后不建议用户去覆盖loadclass()方法 而是建议把自定义的类 加载逻辑写在findClass()方法中</li>
<li>在编写自定义类加载器时候 如果没有太复杂的需求 可以直接继承URLClassLoader类 这样可以避免自己去编写findClass()方法及其获取字节码流 的方式 使自定义类加载器编写更加简洁.</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomClassLoader</span> <span class="keyword">extends</span> <span class="title class_">ClassLoader</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">byte</span>[] result = getClassFromCustomPath(name);</span><br><span class="line">            <span class="keyword">if</span>(result == <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">FileNotFoundException</span>();</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> defineClass(name,result,<span class="number">0</span>,result.length);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ClassNotFoundException</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">byte</span>[] getClassFromCustomPath(String name)&#123;</span><br><span class="line">        <span class="comment">//从自定义路径中加载指定类:细节略</span></span><br><span class="line">        <span class="comment">//如果指定路径的字节码文件进行了加密，则需要在此方法中进行解密操作。</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">CustomClassLoader</span> <span class="variable">customClassLoader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CustomClassLoader</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class&lt;?&gt; clazz = Class.forName(<span class="string">&quot;One&quot;</span>,<span class="literal">true</span>,customClassLoader);</span><br><span class="line">            <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> clazz.newInstance();</span><br><span class="line">            System.out.println(obj.getClass().getClassLoader());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="关于ClassLoader"><a href="#关于ClassLoader" class="headerlink" title="关于ClassLoader"></a>关于ClassLoader</h2><p>它是一个抽象类 其后所有的类加载器 都是继承自ClassLoader</p>
<p><img src="https://gitee.com/xyingtao/blogimage/raw/master/image-20200616150051791-1592870619492.png" alt="image-20200616150051791"></p>
<p><img src="https://gitee.com/xyingtao/blogimage/raw/master/image-20200616154531479-1592870621814.png" alt="image-20200616154531479"></p>
<h3 id="获取ClassLoader的途径"><a href="#获取ClassLoader的途径" class="headerlink" title="获取ClassLoader的途径"></a>获取ClassLoader的途径</h3><p><img src="https://gitee.com/xyingtao/blogimage/raw/master/image-20200616154658641-1592870623887.png" alt="image-20200616154658641"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//1.</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;java.lang.String&quot;</span>).getClassLoader();</span><br><span class="line">        System.out.println(classLoader);</span><br><span class="line">        <span class="comment">//2.</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">classLoader1</span> <span class="operator">=</span> Thread.currentThread().getContextClassLoader();</span><br><span class="line">        System.out.println(classLoader1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">classLoader2</span> <span class="operator">=</span> ClassLoader.getSystemClassLoader().getParent();</span><br><span class="line">        System.out.println(classLoader2);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">null</span></span><br><span class="line"><span class="comment">sun.misc.Launcher$AppClassLoader@18b4aac2</span></span><br><span class="line"><span class="comment">sun.misc.Launcher$ExtClassLoader@1b6d3586</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h1 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h1><p>Java虚拟机对class文件采用的是 <strong>按需加载</strong>的方式 也就是说 当需要使用该类的时候才会将他的class文件加载到内存生成class对象 而且加载某个类的class文件时,java虚拟机采用的是<strong>双亲委派</strong>模式,即把<strong>请求</strong>交给<strong>父类</strong>处理 它是一种任务委派模式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        java.lang.<span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">java</span>.lang.String();</span><br><span class="line">        System.out.println(<span class="string">&quot;hello,atguigu.com&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">StringTest</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringTest</span>();</span><br><span class="line">        System.out.println(test.getClass().getClassLoader());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/xyingtao/blogimage/raw/master/image-20200616155651927-1592870628377.png" alt="image-20200616155651927"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">String</span> &#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是自定义的String类的静态代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//错误: 在类 java.lang.String 中找不到 main 方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello,String&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/xyingtao/blogimage/raw/master/image-20200616160315395-1592870630917.png" alt="image-20200616160315395"></p>
<h2 id="优势"><a href="#优势" class="headerlink" title="优势:"></a>优势:</h2><ul>
<li><p>避免类的重复加载</p>
<p>通过委托可以知道上级是否已经加载过该类,如果加载过了就不再加载</p>
</li>
<li><p>保护程序安全 防止核心API被随意篡改</p>
<ul>
<li>自定义类:java.lang.String</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">XytStart</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="沙箱安全机制"><a href="#沙箱安全机制" class="headerlink" title="沙箱安全机制"></a>沙箱安全机制</h2><p>自定义String类 但是在加载自定义String类的时候会率先使用引导类加载器加载.而引导类加载器在加载的过程中会先加载jdk自带的文件,报错信息说没有 main方法</p>
<p>就是因为加载的是rt.jar包下的String 这样可以保证对java核心源代码的保护 这就是<strong>沙箱安全机制</strong>.</p>
<p>Java安全模型的核心就是<code>Java沙箱</code> </p>
<p>java沙箱就是一个<strong>限制程序运行的环境</strong> 沙箱机制就是将java代码限制在虚拟机特定的运行范围内 严格限制代码对本地资源方位.沙箱主要限制系统资源访问</p>
<p>系统资源包括 <strong>CPU</strong> <strong>内存</strong> <strong>文件系统</strong> <strong>网络</strong></p>
<p>所有的java程序都可以指定沙箱,可以定制安全策略</p>
<p>在java中 代码分为本地代码和远程代码 本地默认可信任 远程不可信</p>
<p>本地代码可以访问本地一切资源 </p>
<p>下图JDK1.0 沙箱 机制</p>
<p><img src="https://gitee.com/xyingtao/blogimage/raw/master/image-20200616164837224-1592870635077.png" alt="image-20200616164837224"></p>
<p><img src="https://gitee.com/xyingtao/blogimage/raw/master/image-20200616165117013-1592870637100.png" alt="image-20200616165117013"></p>
<p><img src="https://gitee.com/xyingtao/blogimage/raw/master/image-20200616165214282-1592870639018.png" alt="image-20200616165214282"></p>
<p><img src="https://gitee.com/xyingtao/blogimage/raw/master/image-20200616165341499-1592870641212.png" alt="image-20200616165341499"></p>
<p><img src="https://gitee.com/xyingtao/blogimage/raw/master/image-20200616165916956-1592870643198.png" alt="image-20200616165916956"></p>
<p><img src="https://gitee.com/xyingtao/blogimage/raw/master/image-20200616170006748-1592870646209.png" alt="image-20200616170006748"></p>
<h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><p>​		JVM必须 知道一个类型是由启动加载器加载的还是由用户类加载器加载的.如果一个类型是由用户类加载器 加载的,那么JVM会将这个<strong>类加载器的一个引用</strong>作为类型信息的一部分保存在方法区中.当解析一个类型到另一个类型的引用的时候,JVM需要保证这两个类型的类加载器是相同的</p>
<h3 id="类的主动使用和被动使用"><a href="#类的主动使用和被动使用" class="headerlink" title="类的主动使用和被动使用"></a>类的主动使用和被动使用</h3><p>在JVM中 两个class对象是否为同一个类的两个必要条件:</p>
<ul>
<li>类的完整类名必须一致 包括包名</li>
<li>加载这个类的ClassLoader(指ClassLoader实例对象) 必须相同</li>
</ul>
<h4 id="主动使用"><a href="#主动使用" class="headerlink" title="主动使用"></a>主动使用</h4><ul>
<li>创建类的实例</li>
<li>访问某个类或接口的<code>静态变量</code> 或者对该静态变量赋值</li>
<li>调用类的<code>静态方法</code></li>
<li>反射</li>
<li>初始化一个类的子类</li>
<li>java虚拟机启动时被标明为启动类的类</li>
<li>JDK7 开始提供的 动态语言支持</li>
</ul>
<p>除了以上其中 其他类的使用方式都是 <strong>被动使用</strong> 都不会导致<strong>类的初始化</strong></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="http://example.com">John Doe</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="http://example.com/2020/09/17/%E6%8A%80%E6%9C%AF/JVM/JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD/">http://example.com/2020/09/17/%E6%8A%80%E6%9C%AF/JVM/JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles on this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless otherwise stated.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/JVM/">JVM</a></div><div class="post-share"><div class="social-share" data-image="/img/butterfly-icon.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2020/09/17/%E6%8A%80%E6%9C%AF/JVM/%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/" title="执行引擎"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">Previous</div><div class="info-item-2">执行引擎</div></div><div class="info-2"><div class="info-item-1">执行引擎 执行引擎是Java虚拟机核心的组成部分之一  “虚拟机”是一个相对于”物理机”的概念,这两种机器都有代码执行能力,其区别是物理机的执行引擎是直接建立在处理器,缓存,指令集和操作系统层面上的,而虚拟机的执行引擎则是由软件自行实现的,因此可以不受物理条件制约地定制指令集与执行引擎的结构体系,能够执行那些不被硬件直接支持的指令集格式  JVM的主要任务是负责装载字节码到内部,但字节码并不能够直接运行在操作系统之上,因为字节码指令并非等价于本地机器指令,它内部包含的仅仅是一些能够被JVM所识别的字节码指令,符号表,以及其他辅助信息  那么,如果想要让一个Java程序运行起来,执行引擎的任务就是将字节码指令解释&#x2F;编译为对应平台上的本地机器指令才可以.简单来说,JVM的执行引擎充当了将高级语言翻译为机器语言的译者    java代码编译和 执行的过程  问题:什么是解释器,什么是JIT编译器?解释器:当Java虚拟机启动的时候会根据预定义的规范对字节码采用逐行解释的方式执行,将每条字节码文件中的内容”翻译”为对应平台的本地机器指令执行 JIT编译器: 就是虚拟机将源代码直...</div></div></div></a><a class="pagination-related" href="/2020/09/17/%E6%8A%80%E6%9C%AF/JVM/JVM/" title="JVM"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">Next</div><div class="info-item-2">JVM</div></div><div class="info-2"><div class="info-item-1">JVM字节码准确的说 任何能在JVM平台上执行的字节码格式都是一样的 所以应该统称为jvm字节码 虚拟机所谓虚拟机 就是一台虚拟的计算机 是一款软件 用来执行一系列虚拟机计算机指令 大体上可分为 系统虚拟机  和 程序虚拟机 Java虚拟机是一台执行 java字节码的虚拟计算机  java技术的核心就是java虚拟机  HotSpot JRocket J9 三大虚拟机 Java虚拟机就是二进制字节码的运行环境 特点:  一次编译 到处运行 自动内存管理 自动垃圾回收机制  jvm是运行在操作系统之上的 它与硬件没有直接的交互  JVM的整体结构 HotSpot VM是目前市面上高性能虚拟机的代表作之一 它采用 解释器和即时编译器 并存的架构  方法区 和 堆  多线程共享 栈 本地方法栈 程序计数器 每个线程独享一份 执行引擎 (3部分) : 解释器(JIT编译器 ) 即时编译器 垃圾回收器 负责 将高级语言 翻译成 机器语言   第一次编译成字节码文件 第二次在JIT编译成机器指令  JVM的架构模型Java编译器输入的指令流基本上是一种基于栈的指令集架构 另外一种指令集架构是...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2020/09/17/%E6%8A%80%E6%9C%AF/JVM/JVM/" title="JVM"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2020-09-17</div><div class="info-item-2">JVM</div></div><div class="info-2"><div class="info-item-1">JVM字节码准确的说 任何能在JVM平台上执行的字节码格式都是一样的 所以应该统称为jvm字节码 虚拟机所谓虚拟机 就是一台虚拟的计算机 是一款软件 用来执行一系列虚拟机计算机指令 大体上可分为 系统虚拟机  和 程序虚拟机 Java虚拟机是一台执行 java字节码的虚拟计算机  java技术的核心就是java虚拟机  HotSpot JRocket J9 三大虚拟机 Java虚拟机就是二进制字节码的运行环境 特点:  一次编译 到处运行 自动内存管理 自动垃圾回收机制  jvm是运行在操作系统之上的 它与硬件没有直接的交互  JVM的整体结构 HotSpot VM是目前市面上高性能虚拟机的代表作之一 它采用 解释器和即时编译器 并存的架构  方法区 和 堆  多线程共享 栈 本地方法栈 程序计数器 每个线程独享一份 执行引擎 (3部分) : 解释器(JIT编译器 ) 即时编译器 垃圾回收器 负责 将高级语言 翻译成 机器语言   第一次编译成字节码文件 第二次在JIT编译成机器指令  JVM的架构模型Java编译器输入的指令流基本上是一种基于栈的指令集架构 另外一种指令集架构是...</div></div></div></a><a class="pagination-related" href="/2021/03/28/%E6%8A%80%E6%9C%AF/JVM/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/" title="垃圾回收"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2021-03-28</div><div class="info-item-2">垃圾回收</div></div><div class="info-2"><div class="info-item-1">垃圾回收jdk14 CMS取消 ZGC迟早有一天替换掉G1 什么是垃圾 垃圾收集,不是Java语言的伴生产物.早在1960年,第一门开始使用内存动态分配和垃圾收集技术的Lisp语言诞生  关于垃圾收集有三个经典问题  哪些内存需要回收 什么时候回收 如何回收    垃圾收集机制是Java的招牌能力,极大地提高了开发效率.如今,垃圾收集几乎成为现代语言的标配,即使经过如此长时间的发展,Java的垃圾收集机制仍然在不断的演进,不同大小设备,不同特征的应用场景,对垃圾收集提出了新的挑战   什么是垃圾呢?  垃圾是指在运行程序中没有任何指针指向的对象 这个对象就是需要被回收的垃圾   如果不及时对内存中的垃圾进行清理 那么这些垃圾对象所占用的内存空间就一直保留到应用程序结束 被保留的空间无法被其他对象使用 甚至可能导致内存溢出   为什么需要GC? 对于高级语言来说,一个基本认知是如果不进行垃圾回收,内存迟早都会被消耗完,因为不断地分配内存空间而不进行回收,就好像不停地生产生活垃圾而从来不打扫一样 除了释放没用的对象,垃圾回收也可以清除内存里的纪录碎片.碎片整理将占用的堆内存存到堆的一...</div></div></div></a><a class="pagination-related" href="/2021/03/28/%E6%8A%80%E6%9C%AF/JVM/%E5%AF%B9%E8%B1%A1%E5%AE%9E%E4%BE%8B%E5%8C%96/" title="对象实例化和内存布局"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2021-03-28</div><div class="info-item-2">对象实例化和内存布局</div></div><div class="info-2"><div class="info-item-1">对象实例化 创建对象的六步骤 虚拟机遇到一条new指令 首先去检查这个指令的参数能否在Metaspace的常量池中定位到一个类的符号引用 并且检查这个符号引用代表的类是否已经被加载 解析和初始化 (即判断类元信息是否存在)  如果没有 那么在双亲委派模式下 使用当前类加载器以ClassLoader+包名+类名为key 查找对应的class文件 如果没有找到 则抛出 ClassNotFoundException异常  如果找到 则进行类加载 并生成对应的class类对象  为对象分配内存(首先计算对象占用空间大小 接着在堆中划分一块内存给新对象 如果实例成员变量是引用变量 仅分配引用变量空间即可 即四个字节大小)  如果内存规整 指针碰撞 意思是 所有用过的内存在一边 空闲的内存在另一边 中间放着一个指针作为分界点的指示器  分配内存就仅仅是把指针往空闲那边挪动一段与对象大小相等的距离.如果垃圾收集器选择的是 Serial ParNew这种基于压缩算法的 虚拟机采用这种分配方式 一般使用带有compat(整理)过程的收集器时,使用指针碰撞  如果内存不规整 已使用的内存和未使用的内...</div></div></div></a><a class="pagination-related" href="/2020/09/17/%E6%8A%80%E6%9C%AF/JVM/%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/" title="执行引擎"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2020-09-17</div><div class="info-item-2">执行引擎</div></div><div class="info-2"><div class="info-item-1">执行引擎 执行引擎是Java虚拟机核心的组成部分之一  “虚拟机”是一个相对于”物理机”的概念,这两种机器都有代码执行能力,其区别是物理机的执行引擎是直接建立在处理器,缓存,指令集和操作系统层面上的,而虚拟机的执行引擎则是由软件自行实现的,因此可以不受物理条件制约地定制指令集与执行引擎的结构体系,能够执行那些不被硬件直接支持的指令集格式  JVM的主要任务是负责装载字节码到内部,但字节码并不能够直接运行在操作系统之上,因为字节码指令并非等价于本地机器指令,它内部包含的仅仅是一些能够被JVM所识别的字节码指令,符号表,以及其他辅助信息  那么,如果想要让一个Java程序运行起来,执行引擎的任务就是将字节码指令解释&#x2F;编译为对应平台上的本地机器指令才可以.简单来说,JVM的执行引擎充当了将高级语言翻译为机器语言的译者    java代码编译和 执行的过程  问题:什么是解释器,什么是JIT编译器?解释器:当Java虚拟机启动的时候会根据预定义的规范对字节码采用逐行解释的方式执行,将每条字节码文件中的内容”翻译”为对应平台的本地机器指令执行 JIT编译器: 就是虚拟机将源代码直...</div></div></div></a><a class="pagination-related" href="/2021/03/06/%E6%8A%80%E6%9C%AF/JVM/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/" title="运行时数据区及线程"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2021-03-06</div><div class="info-item-2">运行时数据区及线程</div></div><div class="info-2"><div class="info-item-1">运行时数据区概述以及线程运行时数据区内部结构 内存是非常重要的系统资源 是硬盘和cpu的中间仓库和桥梁, JVM内存布局 规定了java在运行过程中内存申请 分配 管理的策略,保证了JVM的高效稳定运行. 不同的JVM对于内存划分和管理机制存在部分差异 结合JVM虚拟机规范,探讨经典的JVM内存布局   Java虚拟机定义了若干种程序运行期间会使用到的运行时数据区,其中有一些会随着虚拟机启动而创建,随着虚拟机退出而销毁.另外一些则是与线程一一对应的,这些与线程对应的数据区域会随着线程开始和结束而创建和销毁.  每个线程: 独立包括程序计数器  栈  本地栈  线程间共享: 堆 堆外内存(永久代或元空间, 代码缓存)    线程 线程是一个应用程序里的运行单元 JVM允许一个应用有多个线程并行执行 在HotSpot里 每个线程都与操作系统的本地线程直接映射 当一个java线程准备好执行以后 此时一个操作系统的本地线程也同时创建 java线程执行终止后 本地线程也会回收   操作系统负责所有线程的安排调度到任何一个可用的CPU上 一旦本地线程初始化成功 他就会调用java线程中的ru...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">John Doe</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">78</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">65</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">21</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#JVM%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%92%8C%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B"><span class="toc-number">1.</span> <span class="toc-text">JVM类的加载器和加载过程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%AD%90%E7%B3%BB%E7%BB%9F%E4%BD%9C%E7%94%A8"><span class="toc-number">1.1.</span> <span class="toc-text">类加载器子系统作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-number">1.2.</span> <span class="toc-text">类加载器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B"><span class="toc-number">1.3.</span> <span class="toc-text">类的加载过程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A0%E8%BD%BD"><span class="toc-number">1.3.1.</span> <span class="toc-text">加载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%BE%E6%8E%A5"><span class="toc-number">1.3.2.</span> <span class="toc-text">链接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">1.3.3.</span> <span class="toc-text">初始化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">1.4.</span> <span class="toc-text">类加载器的分类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-number">1.4.1.</span> <span class="toc-text">启动类加载器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8-Extension-Classloader"><span class="toc-number">1.4.2.</span> <span class="toc-text">扩展类加载器(Extension Classloader)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8-%E7%B3%BB%E7%BB%9F%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8-AppClassLoader"><span class="toc-number">1.4.3.</span> <span class="toc-text">应用程序类加载器(系统类加载器 AppClassLoader)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-number">1.4.4.</span> <span class="toc-text">用户自定义类加载器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%AE%9E%E7%8E%B0%E6%AD%A5%E9%AA%A4"><span class="toc-number">1.4.5.</span> <span class="toc-text">自定义类加载器实现步骤</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E4%BA%8EClassLoader"><span class="toc-number">1.5.</span> <span class="toc-text">关于ClassLoader</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96ClassLoader%E7%9A%84%E9%80%94%E5%BE%84"><span class="toc-number">1.5.1.</span> <span class="toc-text">获取ClassLoader的途径</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6"><span class="toc-number">2.</span> <span class="toc-text">双亲委派机制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%98%E5%8A%BF"><span class="toc-number">2.1.</span> <span class="toc-text">优势:</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B2%99%E7%AE%B1%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6"><span class="toc-number">2.2.</span> <span class="toc-text">沙箱安全机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B6%E5%AE%83"><span class="toc-number">2.3.</span> <span class="toc-text">其它</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E4%B8%BB%E5%8A%A8%E4%BD%BF%E7%94%A8%E5%92%8C%E8%A2%AB%E5%8A%A8%E4%BD%BF%E7%94%A8"><span class="toc-number">2.3.1.</span> <span class="toc-text">类的主动使用和被动使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BB%E5%8A%A8%E4%BD%BF%E7%94%A8"><span class="toc-number">2.3.1.1.</span> <span class="toc-text">主动使用</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Posts</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/05/07/%E7%94%9F%E6%B4%BB/%E9%A1%BA%E5%BE%B7%E5%B0%8F%E8%81%9A/" title="顺德好友小聚">顺德好友小聚</a><time datetime="2023-05-07T13:56:00.000Z" title="Created 2023-05-07 21:56:00">2023-05-07</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/05/06/%E7%94%9F%E6%B4%BB/%E6%97%85%E6%B8%B8%E5%BD%92%E6%9D%A5%E7%9A%84%E5%91%A8%E6%9C%AB/" title="旅游归来的周末">旅游归来的周末</a><time datetime="2023-05-06T05:56:00.000Z" title="Created 2023-05-06 13:56:00">2023-05-06</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/05/02/%E7%94%9F%E6%B4%BB/%E5%B9%BF%E8%A5%BF%E4%B9%8B%E6%97%85/" title="与好友的广西之旅">与好友的广西之旅</a><time datetime="2023-05-02T04:30:00.000Z" title="Created 2023-05-02 12:30:00">2023-05-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/08/28/%E6%8A%80%E6%9C%AF/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/B%E7%AB%99%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E8%AF%BE%E7%A8%8B/" title="项目管理笔记"><img src="https://ytblogpic.oss-cn-guangzhou.aliyuncs.com/typora%E6%88%AA%E5%B1%8F2022-08-27%2000.25.25.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="项目管理笔记"/></a><div class="content"><a class="title" href="/2022/08/28/%E6%8A%80%E6%9C%AF/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/B%E7%AB%99%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E8%AF%BE%E7%A8%8B/" title="项目管理笔记">项目管理笔记</a><time datetime="2022-08-28T04:30:00.000Z" title="Created 2022-08-28 12:30:00">2022-08-28</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/08/28/%E6%8A%80%E6%9C%AF/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91/" title="项目管理笔记">项目管理笔记</a><time datetime="2022-08-28T04:30:00.000Z" title="Created 2022-08-28 12:30:00">2022-08-28</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 By John Doe</span><span class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.0</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Reading Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light and Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle Between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Settings"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back to Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>