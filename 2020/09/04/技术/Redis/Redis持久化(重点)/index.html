<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Redis持久化(重点) | Hexo</title><meta name="author" content="John Doe"><meta name="copyright" content="John Doe"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Redis持久化(重点)Redis是内存数据库 如果不将内存中的数据库状态保存到磁盘 那么一旦服务器进程退出 服务器中的数据库状态也会消失 所以redis提供了持久化功能 RDB(Redis DataBase)什么是RDB? 在指定的时间间隔将内存中的数据集快照写入磁盘 也就是行话讲的snapshot 恢复时直接将快照文件读到内存里  Redis会单独创建(fork)一个子进程来进行持久化 会将数">
<meta property="og:type" content="article">
<meta property="og:title" content="Redis持久化(重点)">
<meta property="og:url" content="http://example.com/2020/09/04/%E6%8A%80%E6%9C%AF/Redis/Redis%E6%8C%81%E4%B9%85%E5%8C%96(%E9%87%8D%E7%82%B9)/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="Redis持久化(重点)Redis是内存数据库 如果不将内存中的数据库状态保存到磁盘 那么一旦服务器进程退出 服务器中的数据库状态也会消失 所以redis提供了持久化功能 RDB(Redis DataBase)什么是RDB? 在指定的时间间隔将内存中的数据集快照写入磁盘 也就是行话讲的snapshot 恢复时直接将快照文件读到内存里  Redis会单独创建(fork)一个子进程来进行持久化 会将数">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://gitee.com/xyingtao/blogimage/raw/master/img/redis.jpg">
<meta property="article:published_time" content="2020-09-04T11:51:41.000Z">
<meta property="article:modified_time" content="2020-10-09T12:58:26.000Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="Redis">
<meta property="article:tag" content="持久化">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gitee.com/xyingtao/blogimage/raw/master/img/redis.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Redis持久化(重点)",
  "url": "http://example.com/2020/09/04/%E6%8A%80%E6%9C%AF/Redis/Redis%E6%8C%81%E4%B9%85%E5%8C%96(%E9%87%8D%E7%82%B9)/",
  "image": "https://gitee.com/xyingtao/blogimage/raw/master/img/redis.jpg",
  "datePublished": "2020-09-04T11:51:41.000Z",
  "dateModified": "2020-10-09T12:58:26.000Z",
  "author": [
    {
      "@type": "Person",
      "name": "John Doe",
      "url": "http://example.com"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2020/09/04/%E6%8A%80%E6%9C%AF/Redis/Redis%E6%8C%81%E4%B9%85%E5%8C%96(%E9%87%8D%E7%82%B9)/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Failed',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Redis持久化(重点)',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://gitee.com/xyingtao/blogimage/raw/master/img/redis.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Hexo</span></a><a class="nav-page-title" href="/"><span class="site-name">Redis持久化(重点)</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  Back to Home</span></span></a></span><div id="menus"></div></nav><div id="post-info"><h1 class="post-title">Redis持久化(重点)</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2020-09-04T11:51:41.000Z" title="Created 2020-09-04 19:51:41">2020-09-04</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2020-10-09T12:58:26.000Z" title="Updated 2020-10-09 20:58:26">2020-10-09</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%8A%80%E6%9C%AF/Redis/">Redis</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="Redis持久化-重点"><a href="#Redis持久化-重点" class="headerlink" title="Redis持久化(重点)"></a>Redis持久化(重点)</h1><p>Redis是内存数据库 如果不将内存中的数据库状态保存到磁盘 那么一旦服务器进程退出 服务器中的数据库状态也会消失 所以redis提供了持久化功能</p>
<h2 id="RDB-Redis-DataBase"><a href="#RDB-Redis-DataBase" class="headerlink" title="RDB(Redis DataBase)"></a>RDB(Redis DataBase)</h2><p>什么是RDB?</p>
<p>在指定的时间间隔将内存中的数据集快照写入磁盘 也就是行话讲的snapshot 恢复时直接将快照文件读到内存里 </p>
<p>Redis会单独创建(fork)一个子进程来进行持久化 会将数据写入到一个临时文件中 待持久化过程都结束了 再用这个临时文件替换上次持久化好的文件 整个过程中 主进程是不进行任何IO操作的 这就确保了极高的性能 如果需要进仓库大规模的恢复 且对于数据恢复的完整性不是特别敏感 那RDB方式要比AOF方式更高效  RDB的缺点是 最后一次持久化后的数据可能丢失</p>
<p>默认就是RDB 不需要修改 </p>
<p>RDB保存的文件 &#x3D;&#x3D;dump.rdb&#x3D;&#x3D; 生产环境有时候会将这个文件备份</p>
<p>都是在我们配置文件中的快照进行配置的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dbfilename dump.rdb</span><br></pre></td></tr></table></figure>

<h3 id="触发机制"><a href="#触发机制" class="headerlink" title="触发机制"></a>触发机制</h3><ol>
<li>save规则满足的情况下 会自动触发rdb规则</li>
<li>执行flushall 也会触发rdb规则</li>
<li>退出redis 也会触发rab</li>
</ol>
<p>备份就会自动生成一个rdb文件</p>
<p><strong>1. 自动触发</strong></p>
<p>自动触发是由我们的配置文件来完成的。在redis.conf配置文件中，里面有如下配置，我们可以去设置：</p>
<p>**①save：**这里是用来配置触发 Redis的 RDB 持久化条件，也就是什么时候将内存中的数据保存到硬盘。比如“save m n”。表示m秒内数据集存在n次修改时，自动触发bgsave。</p>
<p>默认如下配置：</p>
<p>#表示900 秒内如果至少有 1 个 key 的值变化，则保存save 900 1#表示300 秒内如果至少有 10 个 key 的值变化，则保存save 300 10#表示60 秒内如果至少有 10000 个 key 的值变化，则保存save 60 10000</p>
<p>不需要持久化，那么你可以注释掉所有的 save 行来停用保存功能。</p>
<p>**②stop-writes-on-bgsave-error ：**默认值为yes。当启用了RDB且最后一次后台保存数据失败，Redis是否停止接收数据。这会让用户意识到数据没有正确持久化到磁盘上，否则没有人会注意到灾难（disaster）发生了。如果Redis重启了，那么又可以重新开始接收数据了</p>
<p>**③rdbcompression ；**默认值是yes。对于存储到磁盘中的快照，可以设置是否进行压缩存储。</p>
<p>**④rdbchecksum ：**默认值是yes。在存储快照后，我们还可以让redis使用CRC64算法来进行数据校验，但是这样做会增加大约10%的性能消耗，如果希望获取到最大的性能提升，可以关闭此功能。</p>
<p>**⑤dbfilename ：**设置快照的文件名，默认是 dump.rdb</p>
<p>**⑥dir：**设置快照文件的存放路径，这个配置项一定是个目录，而不能是文件名。</p>
<p>我们可以修改这些配置来实现我们想要的效果。因为第三种方式是配置的</p>
<p><strong>2. save触发方式</strong></p>
<p>该命令会阻塞当前Redis服务器，执行save命令期间，Redis不能处理其他命令，直到RDB过程完成为止。具体流程如下：</p>
<p><img src="https://gitee.com/xyingtao/blogimage/raw/master/img/e7cd7b899e510fb3aa8c05042b22c093d0430ca7.jpeg" alt="e7cd7b899e510fb3aa8c05042b22c093d0430ca7"></p>
<p>执行完成时候如果存在老的RDB文件，就把新的替代掉旧的。我们的客户端可能都是几万或者是几十万，这种方式显然不可取。</p>
<p><strong>3. bgsave触发方式</strong></p>
<p>执行该命令时，Redis会在后台异步进行快照操作，快照同时还可以响应客户端请求。具体流程如下：</p>
<p><img src="https://gitee.com/xyingtao/blogimage/raw/master/img/023b5bb5c9ea15cefb035bc8431132f53b87b21e.jpeg" alt="023b5bb5c9ea15cefb035bc8431132f53b87b21e"></p>
<p>具体操作是Redis进程执行fork操作创建子进程，RDB持久化过程由子进程负责，完成后自动结束。阻塞只发生在fork阶段，一般时间很短。基本上 Redis 内部所有的RDB操作都是采用 bgsave 命令。</p>
<h3 id="如何恢复"><a href="#如何恢复" class="headerlink" title="如何恢复"></a>如何恢复</h3><ol>
<li>只需要将rdb文件放在redis的启动目录下就可以 redis启动的时候会自动检查dump.rdb  恢复其中的数据</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看目录</span></span><br><span class="line">config get dir</span><br></pre></td></tr></table></figure>

<p>几乎默认的配置已经够用 但是还是需要学习</p>
<h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><p>（1）RDB文件紧凑，全量备份，非常适合用于进行备份和灾难恢复。</p>
<p>（2）生成RDB文件的时候，redis主进程会fork()一个子进程来处理所有保存工作，主进程不需要进行任何磁盘IO操作。</p>
<p>（3）RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快。</p>
<h3 id="劣势"><a href="#劣势" class="headerlink" title="劣势"></a>劣势</h3><p>RDB快照是一次全量备份，存储的是内存数据的二进制序列化形式，存储上非常紧凑。当进行快照持久化时，会开启一个子进程专门负责快照持久化，子进程会拥有父进程的内存数据，父进程修改内存子进程不会反应出来，所以在快照持久化期间修改的数据不会被保存，可能丢失数据。</p>
<h2 id="AOF-Append-Only-File"><a href="#AOF-Append-Only-File" class="headerlink" title="AOF(Append Only File)"></a>AOF(Append Only File)</h2><p>将我们所有命令记录下来 history 恢复的时候吧这个文件全部在执行一遍</p>
<p>以日志的形式记录每个写操作 将redis执行过的所有指令记录下来(读不记录)</p>
<p>只需追加文件但不可以改写文件 redis启动之初会读取该文件重新构建数据 换言之redis重启的话就根据日志文件的内容将写指令从前到后执行一次完成数据的恢复工作</p>
<p>AOF保存的是 appendonly.aof文件 </p>
<p>默认不开启</p>
<p>如果配置文件aof有错误 这时候 redis无法启动</p>
<p>我们需要修复配置文件</p>
<p>redis提供了一个工具<code>redis-check-aof --fix</code></p>
<p>如果文件正常 重启可以直接恢复了 </p>
<p><strong>AOF三种触发机制</strong></p>
<p>（1）每修改同步always：同步持久化 每次发生数据变更会被立即记录到磁盘 性能较差但数据完整性比较好</p>
<p>（2）每秒同步everysec：异步操作，每秒记录 如果一秒内宕机，有数据丢失</p>
<p>（3）不同no：从不同步</p>
<p><img src="https://gitee.com/xyingtao/blogimage/raw/master/img/b17eca8065380cd7df69859ba056a5325982816c.jpeg" alt="b17eca8065380cd7df69859ba056a5325982816c"></p>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>（1）AOF可以更好的保护数据不丢失，一般AOF会每隔1秒，通过一个后台线程执行一次fsync操作，最多丢失1秒钟的数据。</p>
<p>（2）AOF日志文件没有任何磁盘寻址的开销，写入性能非常高，文件不容易破损。</p>
<p>（3）AOF日志文件即使过大的时候，出现后台重写操作，也不会影响客户端的读写。</p>
<p>（4）AOF日志文件的命令通过非常可读的方式进行记录，这个特性非常适合做灾难性的误删除的紧急恢复。比如某人不小心用flushall命令清空了所有数据，只要这个时候后台rewrite还没有发生，那么就可以立即拷贝AOF文件，将最后一条flushall命令给删了，然后再将该AOF文件放回去，就可以通过恢复机制，自动恢复所有数据</p>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>（1）对于同一份数据来说，AOF日志文件通常比RDB数据快照文件更大</p>
<p>（2）AOF开启后，支持的写QPS会比RDB支持的写QPS低，因为AOF一般会配置成每秒fsync一次日志文件，当然，每秒一次fsync，性能也还是很高的</p>
<p>（3）以前AOF发生过bug，就是通过AOF记录的日志，进行数据恢复的时候，没有恢复一模一样的数据出来。</p>
<p><img src="https://gitee.com/xyingtao/blogimage/raw/master/img/8326cffc1e178a82c532308ef2117b8ba977e8ae.jpeg" alt="8326cffc1e178a82c532308ef2117b8ba977e8ae"></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="http://example.com">John Doe</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="http://example.com/2020/09/04/%E6%8A%80%E6%9C%AF/Redis/Redis%E6%8C%81%E4%B9%85%E5%8C%96(%E9%87%8D%E7%82%B9)/">http://example.com/2020/09/04/%E6%8A%80%E6%9C%AF/Redis/Redis%E6%8C%81%E4%B9%85%E5%8C%96(%E9%87%8D%E7%82%B9)/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles on this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless otherwise stated.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Redis/">Redis</a><a class="post-meta__tags" href="/tags/%E6%8C%81%E4%B9%85%E5%8C%96/">持久化</a></div><div class="post-share"><div class="social-share" data-image="https://gitee.com/xyingtao/blogimage/raw/master/img/redis.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2020/09/04/%E6%8A%80%E6%9C%AF/Redis/Redis%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E5%92%8C%E9%9B%AA%E5%B4%A9/" title="Redis缓存穿透和雪崩"><img class="cover" src="https://gitee.com/xyingtao/blogimage/raw/master/img/redis.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">Previous</div><div class="info-item-2">Redis缓存穿透和雪崩</div></div><div class="info-2"><div class="info-item-1">Redis缓存穿透和雪崩Redis缓存的使用 极大的提升了应用程序的性能和效率 特别是数据查询方面 但同时也带来了一些问题 其中最要害的问题就是 数据的一致性问题 从严格意义上讲 这个问题无解 如果对数据的一致性要求很高 那么就不能使用缓存 另外一些典型问题就是 缓存穿透 缓存雪崩 缓存击穿 缓存穿透概念缓存穿透的概念很简单 用户想要查询一个数据 发现redis内存数据库没有 缓存没有命中 于是向持久层数据库查询 发现也没有 于是本次查询失败 当用户很多的时候 缓存都没有命中 于是都去请求了持久层数据库 这会给持久层数据库造成很大的压力 这时候就相当于 出现了缓存穿透 风险 利用不存在的数据进行攻击 造成数据库压力过大 解决方案布隆过滤器布隆过滤器是一种数据结构 对所有可能查询的参数以hash形式存储 在控制层先进行校验 不符合则丢弃 从而避免了对底层存储系统的查询压力   缓存空对象当存储层不命中后 即使返回的空对象也将其缓存起来 同时会设置一个过期时间 之后再访问这个数据将会从缓存中获取 保护了后端数据库  存在两个问题  如果空值能被存储起来 这就意味着缓存需要更多的空间存...</div></div></div></a><a class="pagination-related" href="/2020/09/04/%E6%8A%80%E6%9C%AF/Redis/Redis.conf%E8%AF%A6%E8%A7%A3/" title="Redis.conf详解"><img class="cover" src="https://gitee.com/xyingtao/blogimage/raw/master/img/redis.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">Next</div><div class="info-item-2">Redis.conf详解</div></div><div class="info-2"><div class="info-item-1">Redis.conf详解启动的时候 通过配置文件启动  配置文件unit单位 对大小写不敏感 include包含  include /path/to/local.conf  网络  bind 127.0.0.1  保护模式  Protected-mode yes  端口  port 6379  是否以守护进程方式运行  daemonize yes  如果以后台方式运行 我们就需要指定一个pid文件  pidfile /var/run/redis_6379.pid  日志级别  loglevel notice  生成的日志文件名  logfile &quot;&quot;  默认的数据库数量  databases 16  logo显示(正方形那个)  always-show-logo yes  持久化 在规定时间内  执行了多少次操作 则会持久化到文件 rdb.aof redis 是内存数据库 如果没有持久化  那么数据断电即失   如果 900 s内 至少有1个key修改了 就进行持久化操作 save 900 1 save 300 10  save 60 10000  持久化出现...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2020/09/04/%E6%8A%80%E6%9C%AF/Redis/Redis.conf%E8%AF%A6%E8%A7%A3/" title="Redis.conf详解"><img class="cover" src="https://gitee.com/xyingtao/blogimage/raw/master/img/redis.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2020-09-04</div><div class="info-item-2">Redis.conf详解</div></div><div class="info-2"><div class="info-item-1">Redis.conf详解启动的时候 通过配置文件启动  配置文件unit单位 对大小写不敏感 include包含  include /path/to/local.conf  网络  bind 127.0.0.1  保护模式  Protected-mode yes  端口  port 6379  是否以守护进程方式运行  daemonize yes  如果以后台方式运行 我们就需要指定一个pid文件  pidfile /var/run/redis_6379.pid  日志级别  loglevel notice  生成的日志文件名  logfile &quot;&quot;  默认的数据库数量  databases 16  logo显示(正方形那个)  always-show-logo yes  持久化 在规定时间内  执行了多少次操作 则会持久化到文件 rdb.aof redis 是内存数据库 如果没有持久化  那么数据断电即失   如果 900 s内 至少有1个key修改了 就进行持久化操作 save 900 1 save 300 10  save 60 10000  持久化出现...</div></div></div></a><a class="pagination-related" href="/2020/09/04/%E6%8A%80%E6%9C%AF/Redis/Redis-redis%E5%85%A5%E9%97%A8%E5%92%8C%E5%AE%89%E8%A3%85/" title="Redis入门与安装"><img class="cover" src="https://gitee.com/xyingtao/blogimage/raw/master/img/redis.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2020-09-04</div><div class="info-item-2">Redis入门与安装</div></div><div class="info-2"><div class="info-item-1">Redis入门 从自己之前做的笔记整理 可能有点混乱 会慢慢修改  NoSQL入门概述 为什么用nosql?90年代 一个网站的访问量 一般都不大 单个数据库 完全可以轻松应付.   在那个时候 更多的都是静态网页  动态交互类型的网站不多,随着访问量上升 几乎大部分的mysql架构的网站 在数据库上都开始出现了性能问题  web程序 不再仅仅专注在功能上 同时也追求性能 程序员开始大量使用缓存技术来缓解数据库的压力 优化数据库的结构和索引 由于数据库的写入压力增加 而Memcached只能缓解数据库的读取压力;  读写集中在一个 数据库上让数据库 不堪重负 大部分网站开始使用 主从复制技术来达到读写分离 以提高读写性能和读库的扩展性 Mysql的master-slave模式成为 这个时候网站标配    数据量的持续猛增，由于MyISAM使用表锁，在高并发下会出现严重的锁问题，大量的高并发MySQL应用开始使用InnoDB引擎代替MyISAM。 时，开始流行使用分表分库来缓解写压力和数据增长的扩展问题。这个时候，分表分库成了一个热门技术，是面试的热门问题也是业界讨论的热门技术问题...</div></div></div></a><a class="pagination-related" href="/2020/09/08/%E6%8A%80%E6%9C%AF/Redis/Redis%E4%BA%94%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/" title="Redis五大数据类型"><img class="cover" src="https://gitee.com/xyingtao/blogimage/raw/master/img/redis.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2020-09-08</div><div class="info-item-2">Redis五大数据类型</div></div><div class="info-2"><div class="info-item-1">Redis五大数据类型Key +   string set list hash zset  通用操作指令12345678910111213141516171819#查询当前库的所有键keys * #判断某个键是否存在exists &lt;key&gt; #查看键的类型type &lt;key&gt;#删除某个键del &lt;key&gt;#设置键值对的过期时间 单位:秒expire &lt;key&gt; &lt;seconds&gt;#查看还有多少秒过期 -1永不过期 -2已过期ttl &lt;key&gt;#查看当前数据库key的数量dbsize#清空当前库Flushdb#通杀全部库Flushall    String String是Redis最基本的类型,可以理解成与Memcached一模一样的类型,一个key 对应一个value String类型是二进制安全的,意味着redis的string可以包含任何数据.比如jpg图片或者序列化的对象 String类型是redis最基本的数据类型,一个redis中,字符串value最多可以是512M  基本操作指令123456789...</div></div></div></a><a class="pagination-related" href="/2020/09/04/%E6%8A%80%E6%9C%AF/Redis/Redis%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E5%92%8C%E9%9B%AA%E5%B4%A9/" title="Redis缓存穿透和雪崩"><img class="cover" src="https://gitee.com/xyingtao/blogimage/raw/master/img/redis.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2020-09-04</div><div class="info-item-2">Redis缓存穿透和雪崩</div></div><div class="info-2"><div class="info-item-1">Redis缓存穿透和雪崩Redis缓存的使用 极大的提升了应用程序的性能和效率 特别是数据查询方面 但同时也带来了一些问题 其中最要害的问题就是 数据的一致性问题 从严格意义上讲 这个问题无解 如果对数据的一致性要求很高 那么就不能使用缓存 另外一些典型问题就是 缓存穿透 缓存雪崩 缓存击穿 缓存穿透概念缓存穿透的概念很简单 用户想要查询一个数据 发现redis内存数据库没有 缓存没有命中 于是向持久层数据库查询 发现也没有 于是本次查询失败 当用户很多的时候 缓存都没有命中 于是都去请求了持久层数据库 这会给持久层数据库造成很大的压力 这时候就相当于 出现了缓存穿透 风险 利用不存在的数据进行攻击 造成数据库压力过大 解决方案布隆过滤器布隆过滤器是一种数据结构 对所有可能查询的参数以hash形式存储 在控制层先进行校验 不符合则丢弃 从而避免了对底层存储系统的查询压力   缓存空对象当存储层不命中后 即使返回的空对象也将其缓存起来 同时会设置一个过期时间 之后再访问这个数据将会从缓存中获取 保护了后端数据库  存在两个问题  如果空值能被存储起来 这就意味着缓存需要更多的空间存...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">John Doe</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">78</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">65</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">21</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Redis%E6%8C%81%E4%B9%85%E5%8C%96-%E9%87%8D%E7%82%B9"><span class="toc-number">1.</span> <span class="toc-text">Redis持久化(重点)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#RDB-Redis-DataBase"><span class="toc-number">1.1.</span> <span class="toc-text">RDB(Redis DataBase)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A6%E5%8F%91%E6%9C%BA%E5%88%B6"><span class="toc-number">1.1.1.</span> <span class="toc-text">触发机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%81%A2%E5%A4%8D"><span class="toc-number">1.1.2.</span> <span class="toc-text">如何恢复</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E5%8A%BF"><span class="toc-number">1.1.3.</span> <span class="toc-text">优势</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A3%E5%8A%BF"><span class="toc-number">1.1.4.</span> <span class="toc-text">劣势</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AOF-Append-Only-File"><span class="toc-number">1.2.</span> <span class="toc-text">AOF(Append Only File)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E7%82%B9"><span class="toc-number">1.2.1.</span> <span class="toc-text">优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9"><span class="toc-number">1.2.2.</span> <span class="toc-text">缺点</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Posts</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/05/07/%E7%94%9F%E6%B4%BB/%E9%A1%BA%E5%BE%B7%E5%B0%8F%E8%81%9A/" title="顺德好友小聚">顺德好友小聚</a><time datetime="2023-05-07T13:56:00.000Z" title="Created 2023-05-07 21:56:00">2023-05-07</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/05/06/%E7%94%9F%E6%B4%BB/%E6%97%85%E6%B8%B8%E5%BD%92%E6%9D%A5%E7%9A%84%E5%91%A8%E6%9C%AB/" title="旅游归来的周末">旅游归来的周末</a><time datetime="2023-05-06T05:56:00.000Z" title="Created 2023-05-06 13:56:00">2023-05-06</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/05/02/%E7%94%9F%E6%B4%BB/%E5%B9%BF%E8%A5%BF%E4%B9%8B%E6%97%85/" title="与好友的广西之旅">与好友的广西之旅</a><time datetime="2023-05-02T04:30:00.000Z" title="Created 2023-05-02 12:30:00">2023-05-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/08/28/%E6%8A%80%E6%9C%AF/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/B%E7%AB%99%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E8%AF%BE%E7%A8%8B/" title="项目管理笔记"><img src="https://ytblogpic.oss-cn-guangzhou.aliyuncs.com/typora%E6%88%AA%E5%B1%8F2022-08-27%2000.25.25.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="项目管理笔记"/></a><div class="content"><a class="title" href="/2022/08/28/%E6%8A%80%E6%9C%AF/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/B%E7%AB%99%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E8%AF%BE%E7%A8%8B/" title="项目管理笔记">项目管理笔记</a><time datetime="2022-08-28T04:30:00.000Z" title="Created 2022-08-28 12:30:00">2022-08-28</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/08/28/%E6%8A%80%E6%9C%AF/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91/" title="项目管理笔记">项目管理笔记</a><time datetime="2022-08-28T04:30:00.000Z" title="Created 2022-08-28 12:30:00">2022-08-28</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 By John Doe</span><span class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.0</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Reading Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light and Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle Between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Settings"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back to Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>